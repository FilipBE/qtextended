<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QAtChat Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped Classes</font></a>&nbsp;&middot; <a href="modules-index.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="center"><img src="images/codeless.png" border="0" alt="codeless banner"></td></tr></table><h1 class="title">QAtChat Class Reference<br /><span class="small-subtitle">[<a href="qtbasemodule.html">QtBaseModule</a>]</span>
</h1>
<p>The QAtChat class provides communication with AT-command-based modems. <a href="#details">More...</a></p>
<pre>    #include &lt;QAtChat&gt;</pre><p>Inherits <a href="qobject.html">QObject</a>.</p>
<ul>
<li><a href="qatchat-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/>void <b><a href="qatchat.html#abortDial">abortDial</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qatchat.html#chat">chat</a></b> ( const QString &amp; <i>command</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#chat-2">chat</a></b> ( const QString &amp; <i>command</i>, QObject * <i>target</i>, const char * <i>slot</i>, QAtResult::UserData * <i>data</i> = 0 )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#chatPDU">chatPDU</a></b> ( const QString &amp; <i>command</i>, const QByteArray &amp; <i>pdu</i>, QObject * <i>target</i>, const char * <i>slot</i>, QAtResult::UserData * <i>data</i> = 0 )</li>
<li><div class="fn"/>int <b><a href="qatchat.html#deadTimeout">deadTimeout</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qatchat.html#registerErrorPrefix">registerErrorPrefix</a></b> ( const QString &amp; <i>type</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#registerNotificationType">registerNotificationType</a></b> ( const QString &amp; <i>type</i>, QObject * <i>target</i>, const char * <i>slot</i>, bool <i>mayBeCommand</i> = false )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#registerWakeupCommand">registerWakeupCommand</a></b> ( const QString &amp; <i>cmd</i>, int <i>wakeupTime</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#requestNextLine">requestNextLine</a></b> ( QObject * <i>target</i>, const char * <i>slot</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#resume">resume</a></b> ()</li>
<li><div class="fn"/>int <b><a href="qatchat.html#retryOnNonEcho">retryOnNonEcho</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qatchat.html#send">send</a></b> ( const QString &amp; <i>command</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#setCPINTerminator">setCPINTerminator</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qatchat.html#setDeadTimeout">setDeadTimeout</a></b> ( int <i>msec</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#setDebugChars">setDebugChars</a></b> ( char <i>from</i>, char <i>to</i>, char <i>notify</i>, char <i>unknown</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#setRetryOnNonEcho">setRetryOnNonEcho</a></b> ( int <i>msec</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#suspend">suspend</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qatchat.html#callNotification">callNotification</a></b> ( const QString &amp; <i>type</i> )</li>
<li><div class="fn"/>void <b><a href="qatchat.html#dead">dead</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qatchat.html#pduNotification">pduNotification</a></b> ( const QString &amp; <i>type</i>, const QByteArray &amp; <i>pdu</i> )</li>
</ul>
<ul>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QAtChat class provides communication with AT-command-based modems.</p>
<p>QAtChat is used for sending AT commands to modems and retrieving the responses to those commands. It can be preferable to manually processing the raw binary data from a serial device.</p>
<p>QAtChat objects are obtained by calling <a href="qserialiodevice.html#atchat">QSerialIODevice::atchat</a>() on the serial device that you wish to communicate with. The following example sends the command <tt>AT+CGMI</tt> on <tt>device</tt>. Once the command completes, the result is sent to the <tt>cgmi(bool,QAtResult)</tt> slot on the calling object:</p>
<pre>    QAtChat *atchat = device-&gt;atchat();
    atchat-&gt;chat(&quot;AT+CGMI&quot;, this, SLOT(cgmi(bool,QAtResult)));</pre>
<p>Results from an AT command are reported in two parameters. The first parameter is a simple boolean parameter that allows the slot to quickly determine if the command succeeded (true) or failed (false). The second parameter is a <a href="qatresult.html">QAtResult</a> object that contains detailed information about the command response, or the reason for command failure. The <a href="qatresultparser.html">QAtResultParser</a> class can be used to assist in parsing complex responses to AT commands.</p>
<p>QAtChat objects can also be used to receive unsolicited notifications from the modem device. The caller registers a slot with <a href="qatchat.html#registerNotificationType">registerNotificationType</a>() which is invoked whenever a particular unsolicited notification prefix is encountered in the device's input stream. The following example registers for unsolicited <tt>+CSSI:</tt> notifications from <tt>device</tt>:</p>
<pre>    QAtChat *atchat = device-&gt;atchat();
    atchat()-&gt;registerNotificationType(&quot;+CSSI:&quot;, this, SLOT(cssi(QString)));</pre>
<p>When the corresponding slot is invoked for an unsolicited notification, the entire notification, including the prefix, is passed to the slot as a <a href="qstring.html">QString</a> parameter. The <a href="qatresultparser.html">QAtResultParser</a> class can be used to assist in parsing complex unsolicited notification strings.</p>
<p>See also <a href="qserialiodevice.html">QSerialIODevice</a>, <a href="qatresult.html">QAtResult</a>, and <a href="qatresultparser.html">QAtResultParser</a>.</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="abortDial"></a>void QAtChat::abortDial ()</h3>
<p>Aborts an <tt>ATD</tt> command. Usually just sends and empty line to the modem, but some modems need to use <tt>ATH</tt> instead.</p>
<p>This method calls <a href="qserialiodevice.html#abortDial">QSerialIODevice::abortDial</a>() to perform the abort, which by default sends an empty line to the modem.</p>
<p>Modem-specific multiplexer plug-ins can override <a href="qserialiodevice.html#abortDial">QSerialIODevice::abortDial</a>() to implement alternative abort strategies. The <a href="qatchat.html#send">send</a>() method may be useful to implement such strategies.</p>
<p>See also <a href="qatchat.html#send">send</a>().</p>
<h3 class="fn"><a name="callNotification"></a>void QAtChat::callNotification ( const <a href="qstring.html">QString</a> &amp; <i>type</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted when a call-related notification such as <tt>CONNECT</tt>, <tt>NO CARRIER</tt>, <tt>BUSY</tt>, etc occurs, but which was not associated with a corresponding <tt>ATD</tt> command. The <i>type</i> parameter is the text of the notification.</p>
<h3 class="fn"><a name="chat"></a>void QAtChat::chat ( const <a href="qstring.html">QString</a> &amp; <i>command</i> )</h3>
<p>Sends <i>command</i> to the underlying device. If the command fails, the caller will not be notified.</p>
<p>This version of chat() is useful for commands that the caller is reasonably certain will be understood by the modem, or it is not a serious problem if the command is not understood.</p>
<p>The following example turns on unsolicited <tt>+CRING</tt> notifications for <tt>device</tt>:</p>
<pre>    QAtChat *atchat = device-&gt;atchat();
    atchat-&gt;chat(&quot;AT+CRC=1&quot;);</pre>
<h3 class="fn"><a name="chat-2"></a>void QAtChat::chat ( const <a href="qstring.html">QString</a> &amp; <i>command</i>, <a href="qobject.html">QObject</a> * <i>target</i>, const char * <i>slot</i>, <a href="qatresult-userdata.html">QAtResult::UserData</a> * <i>data</i> = 0 )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Sends <i>command</i> to the underlying device. When the command finishes, notify <i>slot</i> on <i>target</i>.</p>
<p>The optional <i>data</i> parameter can be used to pass extra user data that will be made available to the target slot in the <a href="qatresult.html#userData">QAtResult::userData</a>() field.</p>
<p>The following example sends the command <tt>AT+CGMI</tt> on <tt>device</tt>. Once the command completes, the result is sent to the <tt>cgmi(bool,QAtResult)</tt> slot on the current object:</p>
<pre>    QAtChat *atchat = device-&gt;atchat();
    atchat-&gt;chat(&quot;AT+CGMI&quot;, this, SLOT(cgmi(bool,QAtResult)));</pre>
<p>Results from an AT command are reported to <i>slot</i> in two parameters. The first parameter is a simple boolean parameter that allows the slot to quickly determine if the command succeeded (true) or failed (false). The second parameter is a <a href="qatresult.html">QAtResult</a> object that contains detailed information about the command response, or the reason for command failure. The <a href="qatresultparser.html">QAtResultParser</a> class can be used to assist in parsing complex responses to AT commands.</p>
<p>See also <a href="qatresult.html">QAtResult</a> and <a href="qatresultparser.html">QAtResultParser</a>.</p>
<h3 class="fn"><a name="chatPDU"></a>void QAtChat::chatPDU ( const <a href="qstring.html">QString</a> &amp; <i>command</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>pdu</i>, <a href="qobject.html">QObject</a> * <i>target</i>, const char * <i>slot</i>, <a href="qatresult-userdata.html">QAtResult::UserData</a> * <i>data</i> = 0 )</h3>
<p>Sends <i>command</i> to the underlying device, followed by <i>pdu</i> on the next line. When the command finishes, notify <i>slot</i> on <i>target</i>.</p>
<p>The <i>pdu</i> will be transmitted in hexadecimal, followed by a CTRL-Z.</p>
<p>The optional <i>data</i> parameter can be used to pass extra user data that will be made available to the target slot in the <a href="qatresult.html#userData">QAtResult::userData</a>() field.</p>
<p>The chatPDU() command is intended for AT commands such as <tt>AT+CMGS</tt> which need additional information in the form of a binary PDU.</p>
<p>See also <a href="qatchat.html#chat">chat</a>().</p>
<h3 class="fn"><a name="dead"></a>void QAtChat::dead ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted when the link is detected to be dead.</p>
<p>See also <a href="qatchat.html#deadTimeout">deadTimeout</a>() and <a href="qatchat.html#setDeadTimeout">setDeadTimeout</a>().</p>
<h3 class="fn"><a name="deadTimeout"></a>int QAtChat::deadTimeout () const</h3>
<p>Returns the current link dead detection timeout in milliseconds. If this object sends a command to the link and it does not receive a response within the specified time, it will emit the <a href="qatchat.html#dead">dead</a>() signal. If the value is -1 (the default), the link dead detection timeout will be disabled.</p>
<p>When the link dead detection timeout expires, all pending commands will fail with <a href="qatresult.html#ResultCode-enum">QAtResult::Dead</a> as the result code.</p>
<p>See also <a href="qatchat.html#setDeadTimeout">setDeadTimeout</a>() and <a href="qatchat.html#dead">dead</a>().</p>
<h3 class="fn"><a name="pduNotification"></a>void QAtChat::pduNotification ( const <a href="qstring.html">QString</a> &amp; <i>type</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>pdu</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted when a PDU notification such as <tt>+CMT</tt>, <tt>+CDS</tt>, or <tt>+CBM</tt> arrives. The <i>type</i> parameter contains the type and PDU length (e.g&#x2e; <tt>+CBM: 88</tt>), and the <i>pdu</i> parameter contains the binary data for the PDU.</p>
<h3 class="fn"><a name="registerErrorPrefix"></a>void QAtChat::registerErrorPrefix ( const <a href="qstring.html">QString</a> &amp; <i>type</i> )</h3>
<p>Registers <i>type</i> as a prefix for error strings. Any line of data from the modem that starts with <i>type</i> will be recorded as a synonym for <tt>ERROR</tt>. This is to support modems that have non-standard error strings.</p>
<p>This function was introduced in Qtopia 4.2&#x2e;1</p>
<h3 class="fn"><a name="registerNotificationType"></a>void QAtChat::registerNotificationType ( const <a href="qstring.html">QString</a> &amp; <i>type</i>, <a href="qobject.html">QObject</a> * <i>target</i>, const char * <i>slot</i>, bool <i>mayBeCommand</i> = false )</h3>
<p>Registers <i>type</i> as an unsolicited notification on this object. Whenever a line is received from the modem that starts with <i>type</i>, the indicated <i>slot</i> on <i>target</i> will be called. The slot has the signature <tt>notification(const QString&amp;)</tt>. The entire notification, including the <i>type</i> prefix, will be passed to the slot.</p>
<p>If <i>mayBeCommand</i> is true, then the notification type may sometimes appear as a command result. When it does, the command's completion slot should be called, not the unsolicited notification slot. An example is <tt>+CREG:</tt>, which can appear in response to an <tt>AT+CREG</tt> command, or as an unsolicited notification.</p>
<p>The following example registers for unsolicited <tt>+CSSI:</tt> notifications from <tt>device</tt>:</p>
<pre>    QAtChat *atchat = device-&gt;atchat();
    atchat()-&gt;registerNotificationType(&quot;+CSSI:&quot;, this, SLOT(cssi(QString)));</pre>
<p>When the <tt>cssi()</tt> slot is invoked for the <tt>+CSSI:</tt> unsolicited notification, the entire notification, including the prefix, is passed to the slot as a <a href="qstring.html">QString</a> parameter. The <a href="qatresultparser.html">QAtResultParser</a> class can be used to assist in parsing complex unsolicited notification strings.</p>
<p>See also <a href="qatresultparser.html">QAtResultParser</a>.</p>
<h3 class="fn"><a name="registerWakeupCommand"></a>void QAtChat::registerWakeupCommand ( const <a href="qstring.html">QString</a> &amp; <i>cmd</i>, int <i>wakeupTime</i> )</h3>
<p>Registers <i>cmd</i> as a command to be sent to wake up the modem if no commands have been sent in the last <i>wakeupTime</i> milliseconds.</p>
<p>This function was introduced in Qtopia 4.3&#x2e;1.</p>
<h3 class="fn"><a name="requestNextLine"></a>void QAtChat::requestNextLine ( <a href="qobject.html">QObject</a> * <i>target</i>, const char * <i>slot</i> )</h3>
<p>Requests that the next line from the modem be delivered to <i>slot</i> on <i>target</i>. This is used to collect up extra lines of data on an unsolicited response. The slot takes a single <a href="qstring.html">QString</a> parameter.</p>
<h3 class="fn"><a name="resume"></a>void QAtChat::resume ()</h3>
<p>Resumes the AT chat process after a suspension. Any data that is currently in the buffer will be processed for unsolicited notifications.</p>
<p>See also <a href="qatchat.html#suspend">suspend</a>().</p>
<h3 class="fn"><a name="retryOnNonEcho"></a>int QAtChat::retryOnNonEcho () const</h3>
<p>Returns the retry on non-echo timeout. The default is -1.</p>
<p>See also <a href="qatchat.html#setRetryOnNonEcho">setRetryOnNonEcho</a>().</p>
<h3 class="fn"><a name="send"></a>void QAtChat::send ( const <a href="qstring.html">QString</a> &amp; <i>command</i> )</h3>
<p>Sends <i>command</i> directly to the modem without waiting for a response, and without waiting for any existing commands to complete. This is typically used by modem-specific multiplexer plug-ins that have overridden <a href="qserialiodevice.html#abortDial">QSerialIODevice::abortDial</a>() to send <tt>ATH</tt> or some other command that is different from the default <a href="qatchat.html#abortDial">abortDial</a>() behavior.</p>
<p>See also <a href="qatchat.html#abortDial">abortDial</a>().</p>
<h3 class="fn"><a name="setCPINTerminator"></a>void QAtChat::setCPINTerminator ()</h3>
<p>Sets <tt>+CPIN</tt> as a terminator for the <tt>AT+CPIN?</tt> command. Needed on some modems that do not send <tt>OK</tt>.</p>
<h3 class="fn"><a name="setDeadTimeout"></a>void QAtChat::setDeadTimeout ( int <i>msec</i> )</h3>
<p>Sets the link dead detection timeout to <i>msec</i> milliseconds. If this object sends a command to the link and it does not receive a response within the specified time, it will emit the <a href="qatchat.html#dead">dead</a>() signal. If <i>msec</i> is -1, the link dead detection timeout will be disabled.</p>
<p>When the link dead detection timeout expires, all pending commands will fail with <a href="qatresult.html#ResultCode-enum">QAtResult::Dead</a> as the result code.</p>
<p>See also <a href="qatchat.html#deadTimeout">deadTimeout</a>() and <a href="qatchat.html#dead">dead</a>().</p>
<h3 class="fn"><a name="setDebugChars"></a>void QAtChat::setDebugChars ( char <i>from</i>, char <i>to</i>, char <i>notify</i>, char <i>unknown</i> )</h3>
<p>Sets the characters to use in debug output to <i>from</i>, <i>to</i>, <i>notify</i>, and <i>unknown</i>. The defaults are <tt>F</tt>, <tt>T</tt>, <tt>N</tt>, and <tt>?</tt>. The caller may wish to use different sets on separate channels so that it is clear from the debug output which channel is being used.</p>
<h3 class="fn"><a name="setRetryOnNonEcho"></a>void QAtChat::setRetryOnNonEcho ( int <i>msec</i> )</h3>
<p>Sets the retry on non-echo timeout to <i>msec</i>. If <i>msec</i> is not -1, then if an AT command is not echoed by the modem within the time period, the command will be automatically retried. This is sometimes necessary to restart chat operations after a modem stall.</p>
<p>See also <a href="qatchat.html#retryOnNonEcho">retryOnNonEcho</a>().</p>
<h3 class="fn"><a name="suspend"></a>void QAtChat::suspend ()</h3>
<p>Suspends the AT chat process from the underlying device so that read() and write() can be used to process binary data. Call <a href="qatchat.html#resume">resume</a>() to restart the AT chat process after the binary data.</p>
<p>See also <a href="qatchat.html#resume">resume</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Trolltech</td>
<td align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Extended 4.4.3</div></td>
</tr></table></div></address></body>
</html>

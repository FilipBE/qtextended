<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QIrSocket Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped Classes</font></a>&nbsp;&middot; <a href="modules-index.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="center"><img src="images/codeless.png" border="0" alt="codeless banner"></td></tr></table><h1 class="title">QIrSocket Class Reference</h1>
<p>The QIrSocket class represents an Infrared client socket. <a href="#details">More...</a></p>
<pre>    #include &lt;QIrSocket&gt;</pre><p>Inherits <a href="qiodevice.html">QIODevice</a>.</p>
<ul>
<li><a href="qirsocket-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>enum <b><a href="qirsocket.html#SocketError-enum">SocketError</a></b> { NoError, AccessError, ResourceError, BusyError, ..., UnknownError }</li>
<li><div class="fn"/>enum <b><a href="qirsocket.html#SocketState-enum">SocketState</a></b> { UnconnectedState, ConnectingState, ConnectedState, BoundState, ClosingState }</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qirsocket.html#QIrSocket">QIrSocket</a></b> ( QObject * <i>parent</i> = 0 )</li>
<li><div class="fn"/><b><a href="qirsocket.html#dtor.QIrSocket">~QIrSocket</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qirsocket.html#abort">abort</a></b> ()</li>
<li><div class="fn"/>virtual qint64 <b><a href="qirsocket.html#bytesAvailable">bytesAvailable</a></b> () const</li>
<li><div class="fn"/>virtual qint64 <b><a href="qirsocket.html#bytesToWrite">bytesToWrite</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qirsocket.html#canReadLine">canReadLine</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qirsocket.html#close">close</a></b> ()</li>
<li><div class="fn"/>bool <b><a href="qirsocket.html#connect">connect</a></b> ( const QByteArray &amp; <i>service</i>, quint32 <i>remote</i> )</li>
<li><div class="fn"/>virtual bool <b><a href="qirsocket.html#disconnect">disconnect</a></b> ()</li>
<li><div class="fn"/>SocketError <b><a href="qirsocket.html#error">error</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qirsocket.html#flush">flush</a></b> ()</li>
<li><div class="fn"/>qint64 <b><a href="qirsocket.html#readBufferSize">readBufferSize</a></b> () const</li>
<li><div class="fn"/>quint32 <b><a href="qirsocket.html#remoteAddress">remoteAddress</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qirsocket.html#setReadBufferSize">setReadBufferSize</a></b> ( qint64 <i>size</i> )</li>
<li><div class="fn"/>bool <b><a href="qirsocket.html#setSocketDescriptor">setSocketDescriptor</a></b> ( int <i>socketDescriptor</i>, QIrSocket::SocketState <i>state</i>, QIODevice::OpenMode <i>openMode</i> = QIODevice::ReadWrite )</li>
<li><div class="fn"/>int <b><a href="qirsocket.html#socketDescriptor">socketDescriptor</a></b> () const</li>
<li><div class="fn"/>SocketState <b><a href="qirsocket.html#state">state</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qirsocket.html#waitForConnected">waitForConnected</a></b> ( int <i>msecs</i> = 30000 )</li>
<li><div class="fn"/>bool <b><a href="qirsocket.html#waitForDisconnected">waitForDisconnected</a></b> ( int <i>msecs</i> = 30000 )</li>
</ul>
<ul>
<li><div class="fn"/>32 public functions inherited from <a href="qiodevice.html#public-functions">QIODevice</a></li>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qirsocket.html#connected">connected</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qirsocket.html#disconnected">disconnected</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qirsocket.html#error-2">error</a></b> ( QIrSocket::SocketError <i>socketError</i> )</li>
<li><div class="fn"/>void <b><a href="qirsocket.html#stateChanged">stateChanged</a></b> ( QIrSocket::SocketState <i>socketState</i> )</li>
</ul>
<ul>
<li><div class="fn"/>4 signals inherited from <a href="qiodevice.html#signals">QIODevice</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li><div class="fn"/>5 protected functions inherited from <a href="qiodevice.html#protected-functions">QIODevice</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QIrSocket class represents an Infrared client socket.</p>
<p>At any time, the QIrSocket has a state (returned by <a href="qirsocket.html#state">state</a>()). Upon creation, the initial state is <a href="qirsocket.html#SocketState-enum">QIrSocket::UnconnectedState</a>.</p>
<p>After calling <a href="qirsocket.html#connect">connect</a>(), the socket enters the <a href="qirsocket.html#SocketState-enum">QIrSocket::ConnectingState</a>. If connection is established, the socket enters <a href="qirsocket.html#SocketState-enum">QIrSocket::ConnectedState</a> and emits <a href="qirsocket.html#connected">connected</a>().</p>
<p>If an error occurs at any time, the <a href="qirsocket.html#error">error</a>() signal is emitted. Whenever the state changes, <a href="qirsocket.html#stateChanged">stateChanged</a>() is emitted. For convenience, isValid() returns true if the socket is ready for reading and writing.</p>
<p>Read or write data to/from the socket by calling <a href="qiodevice.html#read">read</a>() or <a href="qiodevice.html#write">write</a>(), or use the convenience functions <a href="qiodevice.html#readLine">readLine</a>() and <a href="qiodevice.html#readAll">readAll</a>(). QIrSocket also inherits <a href="qiodevice.html#getChar">getChar</a>(), <a href="qiodevice.html#putChar">putChar</a>(), and <a href="qiodevice.html#ungetChar">ungetChar</a>() from <a href="qiodevice.html">QIODevice</a>, which work on single bytes. For every chunk of data that has been written to the socket, the <a href="qiodevice.html#bytesWritten">bytesWritten</a>() signal is emitted.</p>
<p>The <a href="qiodevice.html#readyRead">readyRead</a>() signal is emitted every time a new chunk of data has arrived. <a href="qirsocket.html#bytesAvailable">bytesAvailable</a>() then returns the number of bytes that are available for reading. Typically, you would connect the <a href="qiodevice.html#readyRead">readyRead</a>() signal to a slot and read all available data there. If you don't read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to QIrSocket's internal read buffer. To limit the size of the read buffer, call <a href="qirsocket.html#setReadBufferSize">setReadBufferSize</a>().</p>
<p>To close the socket, call <a href="qirsocket.html#disconnect">disconnect</a>(). Once <a href="qirsocket.html#disconnect">disconnect</a>() is called, QIrSocket enters the <a href="qirsocket.html#SocketState-enum">QIrSocket::ClosingState</a> and emits the <a href="qirsocket.html#stateChanged">stateChanged</a>() signal. After all pending data has been written to the socket, QIrSocket actually closes the socket, enters the QIrSocket::ClosedState, and emits <a href="qirsocket.html#disconnected">disconnected</a>(). If no data is pending when <a href="qirsocket.html#disconnect">disconnect</a>() is called, the connection is disconnected immediately. If you want to abort a connection immediately, discarding all pending data, call <a href="qirsocket.html#abort">abort</a>() instead.</p>
<p>QIrSocket provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</p>
<ul>
<li><a href="qirsocket.html#waitForConnected">waitForConnected</a>() blocks until a connection has been established.</li>
<li><a href="qiodevice.html#waitForReadyRead">waitForReadyRead</a>() blocks until new data is available for reading.</li>
<li><a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>() blocks until one payload of data has been written to the socket.</li>
<li><a href="qirsocket.html#waitForDisconnected">waitForDisconnected</a>() blocks until the connection has closed.</li>
</ul>
<p>See also <a href="qirserver.html">QIrServer</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="SocketError-enum"></a>enum QIrSocket::SocketError</h3>
<p>Error that last occurred on the infrared socket.</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QIrSocket::NoError</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">No error has occurred.</td></tr>
<tr><td valign="top"><tt>QIrSocket::AccessError</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The client has inadequate permissions to access the socket.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ResourceError</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">The kernel has run out of sockets.</td></tr>
<tr><td valign="top"><tt>QIrSocket::BusyError</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">Another connect is in progress or device is busy.</td></tr>
<tr><td valign="top"><tt>QIrSocket::HostUnreachableError</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The host is unreachable. This can be caused by an invalid destination address or remote device not being present.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ServiceUnavailableError</tt></td><td align="center" valign="top"><tt>5</tt></td><td valign="top">The host was found, but did not provide the target service.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ConnectionRefused</tt></td><td align="center" valign="top"><tt>6</tt></td><td valign="top">The remote host has refused a connection.</td></tr>
<tr><td valign="top"><tt>QIrSocket::NetworkError</tt></td><td align="center" valign="top"><tt>7</tt></td><td valign="top">A network error has occurred, e.g&#x2e; device moved out of range.</td></tr>
<tr><td valign="top"><tt>QIrSocket::TimeoutError</tt></td><td align="center" valign="top"><tt>8</tt></td><td valign="top">Operation has timed out.</td></tr>
<tr><td valign="top"><tt>QIrSocket::RemoteHostClosedError</tt></td><td align="center" valign="top"><tt>9</tt></td><td valign="top">Remote host has closed the connection.</td></tr>
<tr><td valign="top"><tt>QIrSocket::BusyError</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">The system is busy.</td></tr>
<tr><td valign="top"><tt>QIrSocket::HostUnreachableError</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The remote host could not be reached.</td></tr>
<tr><td valign="top"><tt>QIrSocket::UnsupportedOperationError</tt></td><td align="center" valign="top"><tt>10</tt></td><td valign="top">The operation is not supported.</td></tr>
<tr><td valign="top"><tt>QIrSocket::AddressInUseError</tt></td><td align="center" valign="top"><tt>11</tt></td><td valign="top">Address is currently in use.</td></tr>
<tr><td valign="top"><tt>QIrSocket::AddressNotAvailableError</tt></td><td align="center" valign="top"><tt>12</tt></td><td valign="top">Address is not available.</td></tr>
<tr><td valign="top"><tt>QIrSocket::UnknownError</tt></td><td align="center" valign="top"><tt>13</tt></td><td valign="top">Unknown error has occurred.</td></tr>
</table></p>
<h3 class="fn"><a name="SocketState-enum"></a>enum QIrSocket::SocketState</h3>
<p>State of the infrared socket.</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QIrSocket::UnconnectedState</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">The socket is not connected.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ConnectingState</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The socket is being connected.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ConnectedState</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">The socket is connected.</td></tr>
<tr><td valign="top"><tt>QIrSocket::BoundState</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">The socket has been bound.</td></tr>
<tr><td valign="top"><tt>QIrSocket::ClosingState</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The socket is being closed.</td></tr>
</table></p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QIrSocket"></a>QIrSocket::QIrSocket ( <a href="qobject.html">QObject</a> * <i>parent</i> = 0 )</h3>
<p>Constructs a new <a href="qirsocket.html">QIrSocket</a> with <i>parent</i>. The socket is not connected. The <i>parent</i> specifies the <a href="qobject.html">QObject</a> parent.</p>
<h3 class="fn"><a name="dtor.QIrSocket"></a>QIrSocket::~QIrSocket ()</h3>
<p>Deconstructs a <a href="qirsocket.html">QIrSocket</a>. If the socket is in any state other than <a href="qirsocket.html#SocketState-enum">UnconnectedState</a>, the current connection is aborted.</p>
<h3 class="fn"><a name="abort"></a>void QIrSocket::abort ()</h3>
<p>Aborts the current connection and resets the socket. Unlike <a href="qirsocket.html#disconnect">disconnect</a>(), this function immediately closes the socket, clearing any pending data in the write buffer.</p>
<p>See also <a href="qirsocket.html#disconnect">disconnect</a>() and <a href="qirsocket.html#close">close</a>().</p>
<h3 class="fn"><a name="bytesAvailable"></a><a href="qtglobal.html#qint64-typedef">qint64</a> QIrSocket::bytesAvailable () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the number of bytes that are waiting to be read.</p>
<p>Reimplemented from <a href="qiodevice.html#bytesAvailable">QIODevice</a>.</p>
<p>See also <a href="qirsocket.html#bytesToWrite">bytesToWrite</a>() and <a href="qiodevice.html#read">read</a>().</p>
<h3 class="fn"><a name="bytesToWrite"></a><a href="qtglobal.html#qint64-typedef">qint64</a> QIrSocket::bytesToWrite () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the number of bytes which are pending to be written.</p>
<p>Reimplemented from <a href="qiodevice.html#bytesToWrite">QIODevice</a>.</p>
<p>See also <a href="qirsocket.html#bytesAvailable">bytesAvailable</a>() and <a href="qiodevice.html#write">write</a>().</p>
<h3 class="fn"><a name="canReadLine"></a>bool QIrSocket::canReadLine () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns true if a line of data can be read from the socket; otherwise returns false.</p>
<p>Reimplemented from <a href="qiodevice.html#canReadLine">QIODevice</a>.</p>
<p>See also <a href="qiodevice.html#readLine">readLine</a>().</p>
<h3 class="fn"><a name="close"></a>void QIrSocket::close ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Closes the socket. This is the same as <a href="qirsocket.html#disconnect">disconnect</a>()</p>
<p>Reimplemented from <a href="qiodevice.html#close">QIODevice</a>.</p>
<p>See also <a href="qirsocket.html#abort">abort</a>() and <a href="qirsocket.html#disconnect">disconnect</a>().</p>
<h3 class="fn"><a name="connect"></a>bool QIrSocket::connect ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>service</i>, <a href="qtglobal.html#quint32-typedef">quint32</a> <i>remote</i> )</h3>
<p>Attempts to open an Infrared connection between the local device and the remote device with address <i>remote</i>. The underlying channel will be selected based on <i>service</i> parameter. The service parameter will be looked up in the remote device's IAS Database. This function should generally return immediately, and the socket will enter into the <tt>ConnectingState</tt>.</p>
<p>The function returns true if the connection process could be started, and false otherwise.</p>
<p>Note that the connection could still fail, the state of the socket will be sent in the <a href="qirsocket.html#stateChanged">stateChanged</a>() signal.</p>
<p><b>NOTE:</b> Under LINUX, you can pass 0 for the <tt>remote</tt> parameter. In this case, the kernel will select the first available device which contains an IAS entry that matches the <tt>service</tt> parameter.</p>
<p>See also <a href="qirsocket.html#state">state</a>(), <a href="qirsocket.html#connected">connected</a>(), and <a href="qirsocket.html#waitForConnected">waitForConnected</a>().</p>
<h3 class="fn"><a name="connected"></a>void QIrSocket::connected ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted once the <a href="qirsocket.html#connect">connect</a>() has been called and the socket has been successfully connected.</p>
<p>See also <a href="qirsocket.html#connect">connect</a>() and <a href="qirsocket.html#disconnected">disconnected</a>().</p>
<h3 class="fn"><a name="disconnect"></a>bool QIrSocket::disconnect ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Attempts to close the socket. If there is pending data waiting to be written, the socket will enter <a href="qirsocket.html#SocketState-enum">ClosingState</a> and wait until all data has been written. Eventually it will enter <a href="qirsocket.html#SocketState-enum">UnconnectedState</a> and emit the <a href="qirsocket.html#disconnected">disconnected</a>() signal.</p>
<p>Returns true on successful completion of the request; otherwise returns false.</p>
<p>See also <a href="qirsocket.html#close">close</a>().</p>
<h3 class="fn"><a name="disconnected"></a>void QIrSocket::disconnected ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted when the socket has been disconnected.</p>
<p>See also <a href="qirsocket.html#connect">connect</a>(), <a href="qirsocket.html#disconnect">disconnect</a>(), and <a href="qirsocket.html#abort">abort</a>().</p>
<h3 class="fn"><a name="error"></a><a href="qirsocket.html#SocketError-enum">SocketError</a> QIrSocket::error () const</h3>
<p>Returns the last error that has occurred.</p>
<p>See also <a href="qirsocket.html#state">state</a>().</p>
<h3 class="fn"><a name="error-2"></a>void QIrSocket::error ( <a href="qirsocket.html#SocketError-enum">QIrSocket::SocketError</a> <i>socketError</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>This signal is emitted after an error occurred. The <i>socketError</i> parameter describes the type of error that has occurred.</p>
<p>See also <a href="qirsocket.html#error">error</a>() and <a href="qiodevice.html#errorString">errorString</a>().</p>
<h3 class="fn"><a name="flush"></a>bool QIrSocket::flush ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</p>
<p>See also <a href="qiodevice.html#write">write</a>() and <a href="qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>().</p>
<h3 class="fn"><a name="readBufferSize"></a><a href="qtglobal.html#qint64-typedef">qint64</a> QIrSocket::readBufferSize () const</h3>
<p>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <a href="qiodevice.html#read">read</a>() or <a href="qiodevice.html#readAll">readAll</a>().</p>
<p>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</p>
<p>See also <a href="qirsocket.html#setReadBufferSize">setReadBufferSize</a>() and <a href="qiodevice.html#read">read</a>().</p>
<h3 class="fn"><a name="remoteAddress"></a><a href="qtglobal.html#quint32-typedef">quint32</a> QIrSocket::remoteAddress () const</h3>
<p>Returns the address of the remote device this socket is connected to. If the socket is not connected, this returns 0.</p>
<p>See also <a href="qirsocket.html#connect">connect</a>().</p>
<h3 class="fn"><a name="setReadBufferSize"></a>void QIrSocket::setReadBufferSize ( <a href="qtglobal.html#qint64-typedef">qint64</a> <i>size</i> )</h3>
<p>Sets the capacity of <a href="qirsocket.html">QIrSocket</a>'s internal read buffer to be <i>size</i> bytes. If <i>size</i> is 0 the buffer has unlimited capacity. This is the default.</p>
<p>See also <a href="qirsocket.html#readBufferSize">readBufferSize</a>().</p>
<h3 class="fn"><a name="setSocketDescriptor"></a>bool QIrSocket::setSocketDescriptor ( int <i>socketDescriptor</i>, <a href="qirsocket.html#SocketState-enum">QIrSocket::SocketState</a> <i>state</i>, <a href="qiodevice.html#OpenMode-typedef">QIODevice::OpenMode</a> <i>openMode</i> = QIODevice::ReadWrite )</h3>
<p>Initializes the <a href="qirsocket.html">QIrSocket</a> with the native descriptor <i>socketDescriptor</i>. The socket is put into the <i>state</i> and opened in <i>openMode</i>.</p>
<p>Returns true on successful completion of the request; otherwise returns false.</p>
<p>See also <a href="qirsocket.html#socketDescriptor">socketDescriptor</a>().</p>
<h3 class="fn"><a name="socketDescriptor"></a>int QIrSocket::socketDescriptor () const</h3>
<p>Returns the socket descriptor for the socket if the socket is currently active (e.g&#x2e; not in <a href="qirsocket.html#SocketState-enum">UnconnectedState</a>). Otherwise returns -1.</p>
<p>See also <a href="qirsocket.html#setSocketDescriptor">setSocketDescriptor</a>() and <a href="qirsocket.html#state">state</a>().</p>
<h3 class="fn"><a name="state"></a><a href="qirsocket.html#SocketState-enum">SocketState</a> QIrSocket::state () const</h3>
<p>Returns the state of the socket.</p>
<p>See also <a href="qirsocket.html#error">error</a>().</p>
<h3 class="fn"><a name="stateChanged"></a>void QIrSocket::stateChanged ( <a href="qirsocket.html#SocketState-enum">QIrSocket::SocketState</a> <i>socketState</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted when the state of the socket has changed. The <i>socketState</i> parameter holds the new state.</p>
<p>See also <a href="qirsocket.html#state">state</a>().</p>
<h3 class="fn"><a name="waitForConnected"></a>bool QIrSocket::waitForConnected ( int <i>msecs</i> = 30000 )</h3>
<p>Waits until the socket is connected, up to <i>msecs</i> milliseconds. If the connection has been established, this function returns true; otherwise returns false. In the case where it returns false, you can call <a href="qirsocket.html#error">error</a>() to determine the cause of the error.</p>
<p>This is a blocking function call. Its use is not advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnected() is mostly useful when there is no event loop available.</p>
<p>See also <a href="qirsocket.html#connect">connect</a>() and <a href="qirsocket.html#connected">connected</a>().</p>
<h3 class="fn"><a name="waitForDisconnected"></a>bool QIrSocket::waitForDisconnected ( int <i>msecs</i> = 30000 )</h3>
<p>Waits until the socket is disconnected, up to <i>msecs</i> milliseconds. If the connection has been terminated, this function returns true; otherwise returns false. In the case where it returns false, you can call <a href="qirsocket.html#error">error</a>() to determine the cause of the error.</p>
<p>This is a blocking function call. Its use is not advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForDisconnected() is mostly useful when there is no event loop available.</p>
<p>See also <a href="qirsocket.html#disconnect">disconnect</a>(), <a href="qirsocket.html#close">close</a>(), and <a href="qirsocket.html#disconnected">disconnected</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Trolltech</td>
<td align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Extended 4.4.3</div></td>
</tr></table></div></address></body>
</html>

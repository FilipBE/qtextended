<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QSimFiles Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped Classes</font></a>&nbsp;&middot; <a href="modules-index.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="center"><img src="images/codeless.png" border="0" alt="codeless banner"></td></tr></table><h1 class="title">QSimFiles Class Reference<br /><span class="small-subtitle">[<a href="qttelephonymodule.html">QtTelephonyModule</a>]</span>
</h1>
<p>The QSimFiles class provides an interface for reading and writing the files on a SIM. <a href="#details">More...</a></p>
<pre>    #include &lt;QSimFiles&gt;</pre><p>Inherits <a href="qcomminterface.html">QCommInterface</a>.</p>
<p>Inherited by <a href="qmodemsimfiles.html">QModemSimFiles</a>.</p>
<ul>
<li><a href="qsimfiles-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qsimfiles.html#QSimFiles">QSimFiles</a></b> ( const QString &amp; <i>service</i> = QString(), QObject * <i>parent</i> = 0, QCommInterface::Mode <i>mode</i> = Client )</li>
<li><div class="fn"/><b><a href="qsimfiles.html#dtor.QSimFiles">~QSimFiles</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>1 public function inherited from <a href="qcomminterface.html#public-functions">QCommInterface</a></li>
<li><div class="fn"/>4 public functions inherited from <a href="qabstractipcinterface.html#public-functions">QAbstractIpcInterface</a></li>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h3>Public Slots</h3>
<ul>
<li><div class="fn"/>virtual void <b><a href="qsimfiles.html#readBinary">readBinary</a></b> ( const QString &amp; <i>reqid</i>, const QString &amp; <i>fileid</i>, int <i>pos</i>, int <i>len</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qsimfiles.html#readRecord">readRecord</a></b> ( const QString &amp; <i>reqid</i>, const QString &amp; <i>fileid</i>, int <i>recno</i>, int <i>recordSize</i> = -1 )</li>
<li><div class="fn"/>virtual void <b><a href="qsimfiles.html#requestFileInfo">requestFileInfo</a></b> ( const QString &amp; <i>reqid</i>, const QString &amp; <i>fileid</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qsimfiles.html#writeBinary">writeBinary</a></b> ( const QString &amp; <i>reqid</i>, const QString &amp; <i>fileid</i>, int <i>pos</i>, const QByteArray &amp; <i>data</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qsimfiles.html#writeRecord">writeRecord</a></b> ( const QString &amp; <i>reqid</i>, const QString &amp; <i>fileid</i>, int <i>recno</i>, const QByteArray &amp; <i>data</i> )</li>
</ul>
<ul>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qsimfiles.html#error">error</a></b> ( const QString &amp; <i>reqid</i>, QTelephony::SimFileError <i>err</i> )</li>
<li><div class="fn"/>void <b><a href="qsimfiles.html#fileInfo">fileInfo</a></b> ( const QString &amp; <i>reqid</i>, int <i>size</i>, int <i>recordSize</i>, QTelephony::SimFileType <i>type</i> )</li>
<li><div class="fn"/>void <b><a href="qsimfiles.html#readDone">readDone</a></b> ( const QString &amp; <i>reqid</i>, const QByteArray &amp; <i>data</i>, int <i>pos</i> )</li>
<li><div class="fn"/>void <b><a href="qsimfiles.html#writeDone">writeDone</a></b> ( const QString &amp; <i>reqid</i>, int <i>pos</i> )</li>
</ul>
<ul>
<li><div class="fn"/>1 signal inherited from <a href="qabstractipcinterface.html#signals">QAbstractIpcInterface</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li><div class="fn"/>14 protected functions inherited from <a href="qabstractipcinterface.html#protected-functions">QAbstractIpcInterface</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QSimFiles class provides an interface for reading and writing the files on a SIM.</p>
<p>Client applications should use <a href="qbinarysimfile.html">QBinarySimFile</a> and <a href="qrecordbasedsimfile.html">QRecordBasedSimFile</a> to access SIM files as they provide a cleaner interface. The QSimFiles class is mainly intended for use by service implementations, which inherit from QSimFiles and override the methods described below. <a href="qmodemsimfiles.html">QModemSimFiles</a> is the standard implementation of the service for AT-based modems.</p>
<p>See also <a href="qbinarysimfile.html">QBinarySimFile</a>, <a href="qrecordbasedsimfile.html">QRecordBasedSimFile</a>, and <a href="qmodemsimfiles.html">QModemSimFiles</a>.</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QSimFiles"></a>QSimFiles::QSimFiles ( const <a href="qstring.html">QString</a> &amp; <i>service</i> = QString(), <a href="qobject.html">QObject</a> * <i>parent</i> = 0, <a href="qabstractipcinterface.html#Mode-enum">QCommInterface::Mode</a> <i>mode</i> = Client )</h3>
<p>Construct a new SIM file access object for <i>service</i> and attach it to <i>parent</i>. The object will be created in client mode if <i>mode</i> is Client, or server mode otherwise.</p>
<p>If <i>service</i> is empty, this class will use the first available service that supports SIM file access. If there is more than one service that supports SIM file access, the caller should enumerate them with <a href="qabstractipcinterfacegroupmanager.html#supports">QCommServiceManager::supports</a>() and create separate <a href="qsimfiles.html">QSimFiles</a> objects for each.</p>
<p>Normally this constructor would not be used by client applications. Client applications should use <a href="qbinarysimfile.html">QBinarySimFile</a> and <a href="qrecordbasedsimfile.html">QRecordBasedSimFile</a>. Server applications should inherit from the <a href="qsimfiles.html">QSimFiles</a> class and call this constructor with <i>mode</i> set to <a href="qabstractipcinterface.html#Mode-enum">QCommInterface::Server</a>.</p>
<p>See also <a href="qabstractipcinterfacegroupmanager.html#supports">QCommServiceManager::supports</a>().</p>
<h3 class="fn"><a name="dtor.QSimFiles"></a>QSimFiles::~QSimFiles ()</h3>
<p>Destroy this SIM file access object.</p>
<h3 class="fn"><a name="error"></a>void QSimFiles::error ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, <a href="qtelephony.html#SimFileError-enum">QTelephony::SimFileError</a> <i>err</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Signal that is emitted when the request <i>reqid</i> fails with an error code <i>err</i>.</p>
<p>See also <a href="qsimfiles.html#readBinary">readBinary</a>(), <a href="qsimfiles.html#writeBinary">writeBinary</a>(), <a href="qsimfiles.html#readRecord">readRecord</a>(), and <a href="qsimfiles.html#writeRecord">writeRecord</a>().</p>
<h3 class="fn"><a name="fileInfo"></a>void QSimFiles::fileInfo ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, int <i>size</i>, int <i>recordSize</i>, <a href="qtelephony.html#SimFileType-enum">QTelephony::SimFileType</a> <i>type</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Signal that is emitted when the file information request <i>reqid</i> was successful. The size of the file in bytes is <i>size</i>. If the file is record-based, then <i>recordSize</i> will be the size of the individual records. If the file is binary-based, then <i>recordSize</i> will be 1. The <i>type</i> parameter specifies the actual file type.</p>
<p>See also <a href="qsimfiles.html#requestFileInfo">requestFileInfo</a>().</p>
<h3 class="fn"><a name="readBinary"></a>void QSimFiles::readBinary ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qstring.html">QString</a> &amp; <i>fileid</i>, int <i>pos</i>, int <i>len</i> )&nbsp;&nbsp;<tt> [virtual slot]</tt></h3>
<p>Read <i>len</i> bytes from position <i>pos</i> of the binary file <i>fileid</i>. The <i>reqid</i> parameter indicates a caller-assigned request identifier.</p>
<p>Once the read completes, the <a href="qsimfiles.html#readDone">readDone</a>() signal will be emitted with the same <i>reqid</i>. If the request fails, the <a href="qsimfiles.html#error">error</a>() signal will be emitted.</p>
<p>Client applications should use <a href="qbinarysimfile.html#read">QBinarySimFile::read</a>() instead.</p>
<p>See also <a href="qsimfiles.html#readDone">readDone</a>() and <a href="qsimfiles.html#writeBinary">writeBinary</a>().</p>
<h3 class="fn"><a name="readDone"></a>void QSimFiles::readDone ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>data</i>, int <i>pos</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Signal that is emitted when the read request <i>reqid</i> was successful in reading <i>data</i> from <i>pos</i> in the file.</p>
<p>See also <a href="qsimfiles.html#readBinary">readBinary</a>() and <a href="qsimfiles.html#readRecord">readRecord</a>().</p>
<h3 class="fn"><a name="readRecord"></a>void QSimFiles::readRecord ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qstring.html">QString</a> &amp; <i>fileid</i>, int <i>recno</i>, int <i>recordSize</i> = -1 )&nbsp;&nbsp;<tt> [virtual slot]</tt></h3>
<p>Read record <i>recno</i> the record-based file <i>fileid</i>. The <i>reqid</i> parameter indicates a caller-assigned request identifier.</p>
<p>Once the read completes, the <a href="qsimfiles.html#readDone">readDone</a>() signal will be emitted with the same <i>reqid</i>. If the request fails, the <a href="qsimfiles.html#error">error</a>() signal will be emitted.</p>
<p>If <i>recordSize</i> is not -1, it indicates that the record size is already known. Otherwise the service will determine the record size for itself.</p>
<p>Client applications should use <a href="qrecordbasedsimfile.html#read">QRecordBasedSimFile::read</a>() instead.</p>
<p>See also <a href="qsimfiles.html#readDone">readDone</a>() and <a href="qsimfiles.html#writeRecord">writeRecord</a>().</p>
<h3 class="fn"><a name="requestFileInfo"></a>void QSimFiles::requestFileInfo ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qstring.html">QString</a> &amp; <i>fileid</i> )&nbsp;&nbsp;<tt> [virtual slot]</tt></h3>
<p>Request the current file information for <i>fileid</i>. The <i>reqid</i> parameter indicates a caller-assigned request identifier.</p>
<p>Once the request completes, the <a href="qsimfiles.html#fileInfo">fileInfo</a>() signal will be emitted when the same <i>reqid</i>. If the request fails, the <a href="qsimfiles.html#error">error</a>() signal will be emitted.</p>
<p>Client applications should use <a href="qbinarysimfile.html#requestFileSize">QBinarySimFile::requestFileSize</a>() or <a href="qrecordbasedsimfile.html#requestFileInfo">QRecordBasedSimFile::requestFileInfo</a>() instead.</p>
<p>See also <a href="qsimfiles.html#fileInfo">fileInfo</a>().</p>
<h3 class="fn"><a name="writeBinary"></a>void QSimFiles::writeBinary ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qstring.html">QString</a> &amp; <i>fileid</i>, int <i>pos</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>data</i> )&nbsp;&nbsp;<tt> [virtual slot]</tt></h3>
<p>Write <i>data</i> at position <i>pos</i> of the binary file <i>fileid</i>. The <i>reqid</i> parameter indicates a caller-assigned request identifier.</p>
<p>Once the write completes, the <a href="qsimfiles.html#writeDone">writeDone</a>() signal will be emitted with the same <i>reqid</i>. If the request fails, the <a href="qsimfiles.html#error">error</a>() signal will be emitted.</p>
<p>Client applications should use <a href="qbinarysimfile.html#write">QBinarySimFile::write</a>() instead.</p>
<p>See also <a href="qsimfiles.html#writeDone">writeDone</a>() and <a href="qsimfiles.html#readBinary">readBinary</a>().</p>
<h3 class="fn"><a name="writeDone"></a>void QSimFiles::writeDone ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, int <i>pos</i> )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Signal that is emitted when the write request <i>reqid</i> successfully wrote to position <i>pos</i> of the file.</p>
<p>See also <a href="qsimfiles.html#writeBinary">writeBinary</a>() and <a href="qsimfiles.html#writeRecord">writeRecord</a>().</p>
<h3 class="fn"><a name="writeRecord"></a>void QSimFiles::writeRecord ( const <a href="qstring.html">QString</a> &amp; <i>reqid</i>, const <a href="qstring.html">QString</a> &amp; <i>fileid</i>, int <i>recno</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>data</i> )&nbsp;&nbsp;<tt> [virtual slot]</tt></h3>
<p>Write <i>data</i> at position <i>recno</i> of the record-based file <i>fileid</i>. The <i>reqid</i> parameter indicates a caller-assigned request identifier.</p>
<p>Once the write completes, the <a href="qsimfiles.html#writeDone">writeDone</a>() signal will be emitted with the same <i>reqid</i>. If the request fails, the <a href="qsimfiles.html#error">error</a>() signal will be emitted.</p>
<p>Client applications should use <a href="qrecordbasedsimfile.html#write">QRecordBasedSimFile::write</a>() instead.</p>
<p>See also <a href="qsimfiles.html#writeDone">writeDone</a>() and <a href="qsimfiles.html#readRecord">readRecord</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Trolltech</td>
<td align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Extended 4.4.3</div></td>
</tr></table></div></address></body>
</html>

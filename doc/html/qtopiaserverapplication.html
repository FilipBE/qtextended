<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>QtopiaServerApplication Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped Classes</font></a>&nbsp;&middot; <a href="modules-index.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="center"><img src="images/codeless.png" border="0" alt="codeless banner"></td></tr></table><h1 class="title">QtopiaServerApplication Class Reference<br /><span class="small-subtitle">[<a href="qtbasemodule.html">QtBaseModule</a>]</span>
</h1>
<p>The QtopiaServerApplication class provides additional <a href="qtopiaapplication.html">QtopiaApplication</a> functionality. <a href="#details">More...</a></p>
<pre>    #include &lt;QtopiaServerApplication&gt;</pre><p>Inherits <a href="qtopiaapplication.html">QtopiaApplication</a>.</p>
<ul>
<li><a href="qtopiaserverapplication-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>class <b><a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a></b></li>
<li><div class="fn"/>enum <b><a href="qtopiaserverapplication.html#ShutdownType-enum">ShutdownType</a></b> { NoShutdown, RebootSystem, RestartDesktop, ShutdownSystem, TerminateDesktop }</li>
<li><div class="fn"/>enum <b><a href="qtopiaserverapplication.html#StartupType-enum">StartupType</a></b> { ImmediateStartup, IdleStartup }</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#installQWSEventFilter">installQWSEventFilter</a></b> ( QWSEventFilter * <i>filter</i> )</li>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#removeQWSEventFilter">removeQWSEventFilter</a></b> ( QWSEventFilter * <i>filter</i> )</li>
</ul>
<ul>
<li><div class="fn"/>13 public functions inherited from <a href="qtopiaapplication.html#public-functions">QtopiaApplication</a></li>
<li><div class="fn"/>14 public functions inherited from <a href="qapplication.html#public-functions">QApplication</a></li>
<li><div class="fn"/>4 public functions inherited from <a href="qcoreapplication.html#public-functions">QCoreApplication</a></li>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h3>Public Slots</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#shutdown">shutdown</a></b> ( QtopiaServerApplication::ShutdownType <i>type</i> )</li>
</ul>
<ul>
<li><div class="fn"/>5 public slots inherited from <a href="qapplication.html#public-slots">QApplication</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qcoreapplication.html#public-slots">QCoreApplication</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#shutdownRequested">shutdownRequested</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>9 signals inherited from <a href="qtopiaapplication.html#signals">QtopiaApplication</a></li>
<li><div class="fn"/>4 signals inherited from <a href="qapplication.html#signals">QApplication</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qcoreapplication.html#signals">QCoreApplication</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h3>Static Public Members</h3>
<ul>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#addAggregateObject">addAggregateObject</a></b> ( QObject * <i>me</i>, QObject * <i>them</i> )</li>
<li><div class="fn"/>int &amp; <b><a href="qtopiaserverapplication.html#argc">argc</a></b> ()</li>
<li><div class="fn"/>char ** <b><a href="qtopiaserverapplication.html#argv">argv</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qtopiaserverapplication.html#excludeFromTaskCleanup">excludeFromTaskCleanup</a></b> ( QObject * <i>task</i>, bool <i>exclude</i> )</li>
<li><div class="fn"/>QtopiaServerApplication * <b><a href="qtopiaserverapplication.html#instance">instance</a></b> ()</li>
<li><div class="fn"/>QObject * <b><a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a></b> ( const QByteArray &amp; <i>taskName</i>, bool <i>onlyRunning</i> = false )</li>
<li><div class="fn"/>ShutdownType <b><a href="qtopiaserverapplication.html#shutdownType">shutdownType</a></b> ()</li>
<li><div class="fn"/>bool <b><a href="qtopiaserverapplication.html#startup">startup</a></b> ( int &amp; <i>argc</i>, char ** <i>argv</i>, const QList&lt;QByteArray&gt; &amp; <i>startupGroups</i>, QtopiaServerApplication::StartupType <i>type</i> = QtopiaServerApplication::ImmediateStartup )</li>
<li><div class="fn"/>QString <b><a href="qtopiaserverapplication.html#taskConfigFile">taskConfigFile</a></b> ()</li>
<li><div class="fn"/>QByteArray <b><a href="qtopiaserverapplication.html#taskValueSpaceObject">taskValueSpaceObject</a></b> ( const QByteArray &amp; <i>taskName</i> )</li>
<li><div class="fn"/>bool <b><a href="qtopiaserverapplication.html#taskValueSpaceSetAttribute">taskValueSpaceSetAttribute</a></b> ( const QByteArray &amp; <i>taskName</i>, const QByteArray &amp; <i>attribute</i>, const QVariant &amp; <i>value</i> )</li>
</ul>
<ul>
<li><div class="fn"/>16 static public members inherited from <a href="qtopiaapplication.html#static-public-members">QtopiaApplication</a></li>
<li><div class="fn"/>72 static public members inherited from <a href="qapplication.html#static-public-members">QApplication</a></li>
<li><div class="fn"/>38 static public members inherited from <a href="qcoreapplication.html#static-public-members">QCoreApplication</a></li>
<li><div class="fn"/>4 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="related-non-members"></a>
<h3>Related Non-Members</h3>
<ul>
<li><div class="fn"/>T * <b><a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a></b> ( bool <i>onlyActive</i> = false )</li>
<li><div class="fn"/>QList&lt;T *&gt; <b><a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a></b> ( bool <i>onlyActive</i> = false )</li>
<li><div class="fn"/>T * <b><a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a></b> ( QWidget * <i>parent</i>, Qt::WFlags <i>flags</i> )</li>
</ul>
<a name="macros"></a>
<h3>Macros</h3>
<ul>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_DEMAND_TASK">QTOPIA_DEMAND_TASK</a></b> (  <i>TaskName</i>,  <i>Object</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a></b> (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i>,  <i>Feature</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_STATIC_TASK">QTOPIA_STATIC_TASK</a></b> (  <i>TaskName</i>,  <i>Function</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK">QTOPIA_TASK</a></b> (  <i>TaskName</i>,  <i>Object</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_INTERFACE">QTOPIA_TASK_INTERFACE</a></b> (  <i>ClassName</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_PROVIDES">QTOPIA_TASK_PROVIDES</a></b> (  <i>TaskName</i>,  <i>Interface</i> )</li>
<li><div class="fn"/><b><a href="qtopiaserverapplication.html#QTOPIA_TASK_QINTERFACE">QTOPIA_TASK_QINTERFACE</a></b> (  <i>InterfaceName</i> )</li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>12 properties inherited from <a href="qapplication.html#properties">QApplication</a></li>
<li><div class="fn"/>4 properties inherited from <a href="qcoreapplication.html#properties">QCoreApplication</a></li>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public type inherited from <a href="qobject.html#public-variables">QObject</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
<li><div class="fn"/>2 protected variables inherited from <a href="qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QtopiaServerApplication class provides additional <a href="qtopiaapplication.html">QtopiaApplication</a> functionality.</p>
<a name="qt-extended-server-tasks"></a>
<h3>Qt Extended Server Tasks</h3>
<p>The QtopiaServerApplication class acts as a <a href="qtopiaapplication.html">QtopiaApplication</a> instance in Qt Extended Server. QtopiaServerApplication is primarily responsible for bringing up and shutting down the Qt Extended server and acts as the &quot;core&quot; controller in the system. This class is part of the Qt Extended server and cannot be used by other Qt Extended applications.</p>
<p>The Qt Extended server is structured as a collection of largely independent <i>tasks</i> that are responsible for performing a small, well defined portion of work or functionality which often form the &quot;backend&quot; to other system capabilities. For example, the network management APIs ultimately communicate with the <a href="qtopianetworkserver.html">QtopiaNetworkServer</a> task, other tasks may operate more independently. Tasks can be thought of as the building blocks that form the Qt Extended server, when arranged appropriately.</p>
<p>Tasks are QObjects and may work together by exporting C++ interfaces. Other tasks or modules within the server may request tasks that support a particular interface. For example, when the system is shutting down, all the tasks that provide the <a href="systemshutdownhandler.html">SystemShutdownHandler</a> interface are invoked to perform all the necessary cleanup.</p>
<p>The order in which the task objects are instantiated is configurable. Both the <i>configurator</i> and the task developer has a degree of control over the instantiation order. The <i>configurator</i> controls the start up order through the <tt>$QPEDIR/etc/Tasks.cfg</tt> file which has the following simple syntax:</p>
<pre>    # Sample comment for TaskGroup1.  Comments may appear anywhere, as long as
    # the first character in the line is a '#'
    [TaskGroup1]
    TaskName1
    +TaskGroup2
    # Likewise, blank lines, as well as leading and trailing white space is
    # ignored

    [TaskGroup2]
    TaskName2
    TaskName3</pre>
<p>Task groups are free-form descriptors used to collect related classes. Task group names may only contain alphanumeric characters and must not <i>not</i> contain spaces. A task name is the name given to the task when it is declared in code. It consists of alphanumeric characters and cannot contain spaces. Groups may be nested hierarchically as shown in the example. Nesting one group in another is <i>exactly</i> the same as pasting the body of the nested group into the parent group. The above <tt>Tasks.cfg</tt> file is equivalent to:</p>
<pre>    [TaskGroup1]
    TaskName1
    TaskName2
    TaskName3

    [TaskGroup2]
    TaskName2
    TaskName3</pre>
<a name="reserved-task-group-names"></a>
<h4>Reserved task Group Names</h4>
<p>The following group names are reserved and have a special purpose:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Group Name</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td>prestartup</td><td>The <tt>prestartup</tt> contains tasks that will be started immediately after Qt Extended is executed.</td></tr>
<tr valign="top" class="even"><td>startup</td><td>The <tt>startup</tt> group contains tasks to be launched at startup.</td></tr>
<tr valign="top" class="odd"><td>idle</td><td>The <tt>idle</tt> group contains tasks which will be launched after the UI is shown while the system is idle.</td></tr>
<tr valign="top" class="even"><td>exclude</td><td>The <tt>exclude</tt> group contains tasks that, while present in the server, will <tt>never</tt> be created. Adding a task to the <tt>exclude</tt> group is equivalent to removing it from the server.</td></tr>
<tr valign="top" class="odd"><td>All</td><td>The <tt>All</tt> group is a catch all tasks whose startup preference is not otherwise specified.</td></tr>
</table></p>
<p>How these groups interact will be covered shortly.</p>
<a name="supported-task-types"></a>
<h4>Supported Task Types</h4>
<p>Tasks are constructed in one of two ways: preemptively or on-demand.</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Type</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td>Preemptive Tasks</td><td>Preemptive tasks are those started by the system during startup, regardless of whether or not any other task has asked for it. Some preemptive tasks can have their construction delayed by being placed in the <i>idle</i> group.</td></tr>
<tr valign="top" class="even"><td>On-demand Tasks</td><td>On-demand tasks are those whose creation is deferred until another task requests it be started. Tasks in the <i>startup</i> group in <tt>Tasks.cfg</tt> are the only tasks that are created preemptively. All other tasks (with the exception of those in the <i>exclude</i> group are started on demand.</td></tr>
</table></p>
<p>While it is possible to instantiate an on-demand task by name, it is generally not advisable as doing so often creates unnecessary coupling within the system. Instead, requesters ask the system to return a task that supports a given interface. Doing so allows a particular implementation to be switched out without any code changes to the requestor.</p>
<a name="marking-preemptive-tasks-for-delayed-construction"></a>
<h4>Marking Preemptive Tasks for Delayed Construction</h4>
<p>By default, preemptive tasks are created before the user interface is displayed. This means a task which is expensive to construct delays showing the user interface. To avoid this, tasks in the <tt>Tasks.cfg</tt> file can be marked as suitable for delayed construction by placing them in the <i>idle</i> group.</p>
<p>Tasks in this group will be started shortly after the UI is displayed if the system is idle. If the user interacts with the system, their construction may be further delayed. Tasks which provide background services without any user-visible components are suitable for this group.</p>
<a name="marking-tasks-to-be-started-on-demand"></a>
<h4>Marking Tasks to be Started on Demand</h4>
<p>Tasks in the <tt>Tasks.cfg</tt> file can be marked as demand started tasks by appending the <tt>:demand</tt> to their task name. Similarly, group names can have <tt>:demand</tt> appended, which is equivalent to adding the designator to each of their containing task or sub-group names. Demand tasks will never be picked by the <tt>All</tt> catch all task, but are otherwise subject to all ordering primatives.</p>
<a name="tasks-startup-order"></a>
<h4>Tasks Startup Order</h4>
<p>The <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() templates are used to request a task interface. <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() returns the first task that implements the interface and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() returns all the tasks that implement the interface. Each of these calls takes an optional boolean parameter to indicate whether the system should instantiate a task to satisfy the request (if needed) or only return tasks that have previously been instantiated.</p>
<p>The order of tasks returned by <a href="qtopiaserverapplication.html#qtopiaTask">qtopiaTask</a>() and <a href="qtopiaserverapplication.html#qtopiaTasks">qtopiaTasks</a>() is controllable through the order in which they appear in the <tt>Tasks.cfg</tt> file. Consider the <tt>Tasks.cfg</tt> flattened so that it consists of a list of all groups in the order in which they appear. Each task in this imaginary task list implements zero or more interfaces. The order tasks will be returned when requested by interface is the same order as those tasks appear in this list, with duplicates removed.</p>
<p>As a special &quot;catch-all&quot;, primarily to prevent incorrect configuration, the special <tt>All</tt> task can be added to the <tt>startup</tt> or <tt>idle</tt> group. This has the effect of inserting all tasks not otherwise assigned to a group or explicitly marked as demand started tasks.</p>
<p>While the QtopiaServerApplication class itself is not strictly a task, it is instantiated during startup by the task system in the same way as other tasks under the special task name <tt>QtopiaApplication</tt>. The <tt>QtopiaApplication</tt> task should be instantiated immediately after any environment setup or cleanup type tasks as many other tasks have an implicit reliance on its existence.</p>
<p>The order that the system will try and start preemptive tasks and the order in which tasks will be given interface preference can be read from the value space immediately following the <tt>QtopiaApplication</tt> task executing. The exact schema is:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Item</th><th>Type</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Static</tt></td><td>int</td><td>The preemptive order that the system determined it would launch tasks. This may be different from the actual order if one task demand loads another that would otherwise be loaded later.</td></tr>
<tr valign="top" class="even"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Launch</tt></td><td>int</td><td>The order that the tasks were actually launched in. This key will only exist if the task is active.</td></tr>
<tr valign="top" class="odd"><td><tt>/System/Tasks/&lt;TaskName&gt;/Order/Interface</tt></td><td>int</td><td>The order that the task will be given when determining interface associations.</td></tr>
<tr valign="top" class="even"><td><tt>/System/Tasks/&lt;TaskName&gt;/State</tt></td><td>String</td><td>&quot;Disable&quot; if the task was in the <tt>exclude</tt> list, &quot;Active&quot; if the task is running, or &quot;Inactive&quot; if not.</td></tr>
</table></p>
<p>A tutorial on how to develop new server tasks can be found in the <a href="integration-guide.html#server-tasks">Device Integration guide</a>.</p>
<a name="server-task-plug-ins"></a>
<h4>Server task plug-ins</h4>
<p>The above server tasks are linked into the Qt Extended server at build time. To increase the flexibility server tasks can be provided via a plug-in mechanism. This allows the addition of new tasks after the deployment of the server binary. Server task plugins must implement the <a href="servertaskplugin.html">ServerTaskPlugin</a> interface in order to be recognized by the system.</p>
<p>For more information on how to develop plug-in based server tasks refer to the <a href="server-plugins-exampletask.html">Server task plug-in tutorial</a>.</p>
<a name="qt-extended-server-widgets"></a>
<h3>Qt Extended Server Widgets</h3>
<p>There are many cases of Qt widgets being used throughout the Qt Extended server that may need to be customized to achieve a desired look and feel. For example, while it supports customization through theming, a customer that wants to replace the Qt Extended phone dialer with a &quot;rotary dial&quot; style dialer would need to replace the entire dialer widget.</p>
<p>To simplify the task and minimize the code changes needed to replace visual components of the Qt Extended Server, the concept of Qt Extended Server Widgets exists. Qt Extended Server Widgets splits the definition of a visual component - or server widget - into two parts: the server widget interface (hereafter referred to as the AbstractWidget) and the concrete server widget implementation (ConcreteWidget). While not technically necessary, the AbstractWidget is generally an abstract interface that derives directly from <a href="qwidget.html">QWidget</a>.</p>
<p>Rather than using the regular <tt>new ClassName(parent, flags)</tt> syntax for instantiating a widget, the special <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() template method, parameterized on AbstractWidget, is provided. This method uses the server widgets replacement system to look up the ConcreteWidget instance type it should return.</p>
<p>Developers use the <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a>(), <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() and <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a>() macros to provide ConcreteWidget for a particular AbstractWidget. The server widget replacement system then resolves which ConcreteWidget to return by executing the following set of rules in order until a ConcreteWidget is determined.</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Rule</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td>Explicitly specified</td><td>The <tt>Trolltech/ServerWidgets</tt> configuration file is read to determine if the ConcreteWidget to use has been explicitly specified. The configuration file contains one group, <tt>Mapping</tt> that contains mappings between <i>AbstractName</i> and <i>ConcreteName</i>. How these two names are determined is discussed below. For example,<pre>    [Mapping]
    BrowserScreen=Wheel
    DialerScreen=Rotary</pre>
<p>Unless the specified widget does not exist, the mapping is always honored. That is, using <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() can not override explicitly specified widgets. The special name <tt>None</tt> will disable the widget, causing <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() to always return null.</p>
</td></tr>
<tr valign="top" class="even"><td>Primary Default</td><td>The primary default is the value of the <tt>Mapping/Default</tt> key, or <tt>Default</tt> if not specified. The primary default name is tried as the <i>ConcreteName</i>. Feature dependencies are honored.</td></tr>
<tr valign="top" class="odd"><td>Other Defaults</td><td>All <i>ConcreteName</i>'s beginning with the primary default name are tried. Feature dependencies are honored.</td></tr>
<tr valign="top" class="even"><td>All Replacements</td><td>All available ConcreteWidgets are tried. Feature dependencies are honored.</td></tr>
</table></p>
<p>The <i>AbstractName</i> and <i>ConcreteName</i> names used to identify a server widget are derived from the widget class names. <i>AbstractName</i> is set to the AbstractWidget's full name, unless the name begins with <tt>QAbstract</tt> in which case it is set to the widget class name, minus the <tt>QAbstract</tt> prefix. The <i>ConcreteName</i> is set to the class name of the ConcreteWidget, unless the class name ends with the <i>AbstractName</i> of the widget it is replacing, in which case it is set to the widget class name minus the <i>AbstractName</i> suffix. These rules are designed to simplify writing mapping files - a class <tt>WheelBrowserScreen</tt> replacing <tt>QAbstractBrowserScreen</tt> is written as <tt>BrowserScreen=Wheel</tt> rather than <tt>QAbstractBrowserScreen=WheelBrowserScreen</tt>.</p>
<p>The following image also demonstrates the widget selection process:</p>
<p align="center"><img src="images/WidgetSelectionRules.png" alt="&quot;Selecting the correct Server Widget&quot;" /></p><a name="singleton-pattern"></a>
<h4>Singleton pattern</h4>
<p>Usually each call to <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() returns a new server widget instance. In some cases this behaviour is not desired. If it is necessary to return a reference to an already existing instance of a server widget Qt's meta system class info should be used to mark an abstract server widget as singleton. This means that every concrete implementation of this abstract widget will follow the singleton pattern. The <tt>SingletonServerWidget</tt> string is reserved to enable this feature. If the class info tag is missing Qt Extended assumes that the class does not follow the singleton pattern.</p>
<p>For example:</p>
<pre>      <span class="comment">//qabstracthomescreen.h</span>
      class QAbstractHomeScreen : public QWidget
      {
         QOBJECT
         Q_CLASSINFO(&quot;SingletonServerWidget&quot;, &quot;true&quot;);
         <span class="comment">// ...</span>
      };</pre>
<p>The following code segment demonstrates the difference:</p>
<pre>      QAbstractHomeScreen* ref1 = qtopiaWidget&lt;QAbstractHomeScreen&gt;();
      QAbstractHomeScreen* ref2 = qtopiaWidget&lt;QAbstractHomeScreen&gt;();

      if ( ref1 == ref2 ) {
          ...
          <span class="comment">//The SingletonServerWidget class info is set to true for</span>
          <span class="comment">//QAbstractHomeScreen (as seen in above example).</span>
      } else {
          ...
          <span class="comment">//The SingletonServerWidget class info is set to false</span>
          <span class="comment">//or not defined at all.&quot;;</span>
      }</pre>
<p>A tutorial on how to develop new server widgets can be found in the <a href="qabstractserverinterface.html">QAbstractServerInterface</a> class documentation and the <a href="integration-guide.html#server-widgets">Device Integration guide</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="ShutdownType-enum"></a>enum QtopiaServerApplication::ShutdownType</h3>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::NoShutdown</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">No shutdown has been requested.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::RebootSystem</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">The server terminates and initiates the reboot of the system.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::RestartDesktop</tt></td><td align="center" valign="top"><tt>3</tt></td><td valign="top">The server terminates and requests its restart by the calling environment.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::ShutdownSystem</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The server terminates and initiates the shutdown of the system.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::TerminateDesktop</tt></td><td align="center" valign="top"><tt>4</tt></td><td valign="top">The server terminates only.</td></tr>
</table></p>
<h3 class="fn"><a name="StartupType-enum"></a>enum QtopiaServerApplication::StartupType</h3>
<p>This enum determines how tasks are started when <a href="qtopiaserverapplication.html#startup">QtopiaServerApplication::startup</a>() is called.</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::ImmediateStartup</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">Requested tasks are started immediately. The call to <a href="qtopiaserverapplication.html#startup">startup</a>() will block until all requested tasks have been started.</td></tr>
<tr><td valign="top"><tt>QtopiaServerApplication::IdleStartup</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">Requested tasks are queued to be started when the server is idle. The call to <a href="qtopiaserverapplication.html#startup">startup</a>() is non-blocking.</td></tr>
</table></p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="addAggregateObject"></a>void QtopiaServerApplication::addAggregateObject ( <a href="qobject.html">QObject</a> * <i>me</i>, <a href="qobject.html">QObject</a> * <i>them</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Add an object <i>them</i> to <i>me</i> to create an &quot;aggregate&quot; task. Aggregate tasks are designed to work around the limitations in Qt's support for multiple interface inheritance by allowing multiple objects to be &quot;stuck together&quot; to form a single object from the task system's perspective.</p>
<p>For example, consider the following interfaces:</p>
<pre>    class ApplicationTypeLauncher : public QObject {};
    QTOPIA_TASK_INTERFACE(ApplicationTypeLauncher);
    class SystemShutdownHandler : public QObject {};
    QTOPIA_TASK_INTERFACE(SystemShutdownHandler);</pre>
<p>Using direct inheritance a single task could not implement both interfaces. Instead, a task can create one object that implements the <tt>ApplicationTypeLauncher</tt> interface and one that implements the <tt>SystemShutdownHandler</tt> interface and aggregate them together.</p>
<pre>    class MyLauncherShutdown : public SystemShutdownHandler
    {
    public:
        MyLauncherShutdown(MyLauncherType *);
    };

    class MyLauncherType : public ApplicationTypeLauncher
    {
    public:
        MyLauncherType()
        {
            MyLauncherShutdown *s = new MyLauncherShutdown(this);
            QtopiaServerApplication::addAggregateObject(this, s);
        }
    };
    QTOPIA_TASK(MyLauncherType, MyLauncherType);
    QTOPIA_TASK_PROVIDES(MyLauncherType, ApplicationTypeLauncher);
    QTOPIA_TASK_PROVIDES(MyLauncherType, SystemShutdownHandler);</pre>
<p>When the system attempts to cast a task to a particular interface, it first tries the task object itself, and then each of the aggregate objects for that task.</p>
<h3 class="fn"><a name="argc"></a>int &amp; QtopiaServerApplication::argc ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the argc reference passed to <a href="qtopiaserverapplication.html#startup">startup</a>().</p>
<h3 class="fn"><a name="argv"></a>char ** QtopiaServerApplication::argv ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the argv reference passed to <a href="qtopiaserverapplication.html#startup">startup</a>().</p>
<h3 class="fn"><a name="excludeFromTaskCleanup"></a>void QtopiaServerApplication::excludeFromTaskCleanup ( <a href="qobject.html">QObject</a> * <i>task</i>, bool <i>exclude</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>During the server shutdown all object based server tasks are deleted. However some tasks may not require such management as they install themselves into some form of backend functionality which may take care of the tasks life time. Setting <i>exclude</i> to true excludes <i>task</i> from the task system's memory management.</p>
<p>An example is the <a href="qtopiapowermanager.html">QtopiaPowerManager</a> and its sub class which installs itself as the screensaver. The QWS server owns the screen saver object and therefore takes already care of the objects life time.</p>
<h3 class="fn"><a name="installQWSEventFilter"></a>void QtopiaServerApplication::installQWSEventFilter ( <a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a> * <i>filter</i> )</h3>
<p>Install the <i>filter</i> for QWS events. Installing an event filter is equivalent to deriving from <a href="qtopiaapplication.html">QtopiaApplication</a> directly and overriding the <a href="qapplication.html#qwsEventFilter">QtopiaApplication::qwsEventFilter</a>() method.</p>
<p>Multiple QWS event filters may be installed simultaneously. In this case, each event filter is queried sequentially in the order it was installed. If any filter filters the event, subsequent filters will not be called.</p>
<h3 class="fn"><a name="instance"></a>QtopiaServerApplication * QtopiaServerApplication::instance ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Return the instantiated <a href="qtopiaserverapplication.html">QtopiaServerApplication</a> instance. An instance of the class <b>must</b> have been constructed prior to calling this method.</p>
<h3 class="fn"><a name="qtopiaTask"></a><a href="qobject.html">QObject</a> * QtopiaServerApplication::qtopiaTask ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i>, bool <i>onlyRunning</i> = false )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Return the task with name <i>taskName</i>. If <i>onlyRunning</i> is true, the task will be returned only if it has already been instantiated, otherwise it will be instantiated and returned.</p>
<h3 class="fn"><a name="removeQWSEventFilter"></a>void QtopiaServerApplication::removeQWSEventFilter ( <a href="qtopiaserverapplication-qwseventfilter.html">QWSEventFilter</a> * <i>filter</i> )</h3>
<p>Remove all instances of <i>filter</i> from the list of event filters. This method should be called when an event filter is destroyed. No automatic cleanup is performed.</p>
<h3 class="fn"><a name="shutdown"></a>void QtopiaServerApplication::shutdown ( <a href="qtopiaserverapplication.html#ShutdownType-enum">QtopiaServerApplication::ShutdownType</a> <i>type</i> )&nbsp;&nbsp;<tt> [slot]</tt></h3>
<p>Initiates a system shutdown of the specified <i>type</i>.</p>
<h3 class="fn"><a name="shutdownRequested"></a>void QtopiaServerApplication::shutdownRequested ()&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>Emitted whenever the user or an application requests that the system shutdown. A system shutdown is requested by sending a <tt>shutdown()</tt> message to the <tt>QPE/System</tt> QCop channel.</p>
<p>Generally a UI will be connected to the shutdownRequested() signal to ask the user what they want to do. This UI should then invoke the <a href="qtopiaserverapplication.html#shutdown">shutdown</a>() method to perform the appropriate action.</p>
<h3 class="fn"><a name="shutdownType"></a><a href="qtopiaserverapplication.html#ShutdownType-enum">ShutdownType</a> QtopiaServerApplication::shutdownType ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the type of shutdown previously requested by calling <a href="qtopiaserverapplication.html#shutdown">shutdown</a>(), or <a href="qtopiaserverapplication.html#ShutdownType-enum">NoShutdown</a> if no shutdown has been requested.</p>
<h3 class="fn"><a name="startup"></a>bool QtopiaServerApplication::startup ( int &amp; <i>argc</i>, char ** <i>argv</i>, const <a href="qlist.html">QList</a>&lt;<a href="qbytearray.html">QByteArray</a>&gt; &amp; <i>startupGroups</i>, <a href="qtopiaserverapplication.html#StartupType-enum">QtopiaServerApplication::StartupType</a> <i>type</i> = QtopiaServerApplication::ImmediateStartup )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Launches server tasks. This method is used to start the Qt Extended server and should never be called from other code. Returns true on success, false on failure.</p>
<p><i>argc</i> and <i>argv</i> should be the values passed to the main() function. <i>startupGroups</i> contains a list of Task groups to start. <i>type</i> determines the behavior for launching the tasks.</p>
<h3 class="fn"><a name="taskConfigFile"></a><a href="qstring.html">QString</a> QtopiaServerApplication::taskConfigFile ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the task system's configuration file.</p>
<h3 class="fn"><a name="taskValueSpaceObject"></a><a href="qbytearray.html">QByteArray</a> QtopiaServerApplication::taskValueSpaceObject ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns the path to an object in the value space that the task <i>taskName</i> can use to store status information. Will return a null byte array if the value space has not been initialized. This method is for task implementors only.</p>
<h3 class="fn"><a name="taskValueSpaceSetAttribute"></a>bool QtopiaServerApplication::taskValueSpaceSetAttribute ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>taskName</i>, const <a href="qbytearray.html">QByteArray</a> &amp; <i>attribute</i>, const <a href="qvariant.html">QVariant</a> &amp; <i>value</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Sets a value space <i>attribute</i> for task <i>taskName</i> to <i>value</i>. This is a convenience method to simplify the usage of the value space for a task. For more complex usage, tasks should use the <a href="qtopiaserverapplication.html#taskValueSpaceObject">taskValueSpaceObject</a>() to request a path, and manually create a <a href="qvaluespaceobject.html">QValueSpaceObject</a> for their own use. Returns true upon success; otherwise returns false.</p>
<p>The value remains in the value space until the task is unloaded.</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="qtopiaTask"></a>T * qtopiaTask ( bool <i>onlyActive</i> = false )</h3>
<p>Return a task instance that supports the T interface. If <i>onlyActive</i> is true the system will only select from tasks that are already active. Otherwise, if needed, the system will instantiate tasks to satisfy the request.</p>
<h3 class="fn"><a name="qtopiaTasks"></a><a href="qlist.html">QList</a>&lt;T *&gt; qtopiaTasks ( bool <i>onlyActive</i> = false )</h3>
<p>Returns all task instances that support the T interface. The instances are in the intended instantiation order. If <i>onlyActive</i> is true the system will only select from tasks that are already active. Otherwise, if needed, the system will instantiate tasks to satisfy the request.</p>
<h3 class="fn"><a name="qtopiaWidget"></a>T * qtopiaWidget ( <a href="qwidget.html">QWidget</a> * <i>parent</i>, <a href="qt.html#WFlags-typedef">Qt::WFlags</a> <i>flags</i> )</h3>
<p>Returns a concrete implementation of T, with the specified <i>parent</i> and <i>flags</i>. Concrete implementations are provided with the <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET">QTOPIA_REPLACE_WIDGET</a>(), <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_WHEN">QTOPIA_REPLACE_WIDGET_WHEN</a>() and <a href="qtopiaserverapplication.html#QTOPIA_REPLACE_WIDGET_OVERRIDE">QTOPIA_REPLACE_WIDGET_OVERRIDE</a>() macros and selected as described in the <a href="qtopiaserverapplication.html#qt-extended-server-widgets">Qt Extended Server Widgets</a> overview.</p>
<p>Each call to this function returns a new instance of the requested server widget unless the server widget has been marked as singleton widget via</p>
<pre>    Q_CLASSINFO(&quot;SingletonServerWidget&quot;, &quot;true&quot;);</pre>
<hr />
<h2>Macro Documentation</h2>
<h3 class="fn"><a name="QTOPIA_DEMAND_TASK"></a>QTOPIA_DEMAND_TASK (  <i>TaskName</i>,  <i>Object</i> )</h3>
<p>Mark the <i>Object</i> as task <i>TaskName</i>. Only <a href="qobject.html">QObject</a> derived types may be tasks. QTOPIA_DEMAND_TASK() differs from <a href="qtopiaserverapplication.html#QTOPIA_TASK">QTOPIA_TASK</a>() in that tasks installed using this macro are automatically marked as &quot;demand&quot; tasks, unless specifically overridden in the <tt>Tasks.cfg</tt> file. That is, tasks installed like this will only be instantiated on request, not during server startup.</p>
<p>As the QTOPIA_DEMAND_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET"></a>QTOPIA_REPLACE_WIDGET (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</h3>
<p>Mark <i>ConcreteWidget</i> as a replacement for <i>AbstractWidget</i>. While <i>AbstractWidget</i> does not actually have to be abstract, it is generally an interface that <i>ConcreteWidget</i> implements. This macro should appear as part of the definition of <i>ConcreteWidget</i>.</p>
<p>For example,</p>
<pre><span class="comment">    // wheelbrowserscreen.h</span>
    class WheelBrowserScreen : public QAbstractBrowserScreen
    {
        <span class="comment">// ...</span>
    };

<span class="comment">    // wheelbrowserscreen.cpp</span>
    QTOPIA_REPLACE_WIDGET(QAbstractBrowserScreen, WheelBrowserScreen);</pre>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET_OVERRIDE"></a>QTOPIA_REPLACE_WIDGET_OVERRIDE (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i> )</h3>
<p>Set <i>ConcreteWidget</i> as the <b>static</b> replacement for <i>AbstractWidget</i>.</p>
<p>While as efficient as possible, use of the widget replacement system instead of explicitly instantiating concrete classes does introduce some indirection costs. For shipping software where this flexibility is not necessary, QTOPIA_REPLACE_WIDGET_OVERRIDE() can be used to force the selection of a specified <i>ConcreteWidget</i>. This eliminates the cost of the widget replacement system for the particular <i>AbstractWidget</i> by bypassing the replacement system. The macro should appear inline with the <i>AbstractWidget</i> declaration, and must have visibility of the <i>ConcreteWidget</i>'s declaration.</p>
<p>For example,</p>
<pre><span class="comment">    // qabstractbrowserscreen.h</span>
    class QAbstractBrowserScreen : public QWidget
    {
        <span class="comment">// ...</span>
    };

    #include &quot;wheelbrowserscreen.h&quot;
    QTOPIA_REPLACE_WIDGET_OVERRIDE(QAbstractBrowserScreen, WheelBrowserScreen);</pre>
<p>Note that any server widget that uses this marco will not work with singleton server widgets. Calling <a href="qtopiaserverapplication.html#qtopiaWidget">qtopiaWidget</a>() on such widgets will always return a new instance.</p>
<h3 class="fn"><a name="QTOPIA_REPLACE_WIDGET_WHEN"></a>QTOPIA_REPLACE_WIDGET_WHEN (  <i>AbstractWidget</i>,  <i>ConcreteWidget</i>,  <i>Feature</i> )</h3>
<p>Mark <i>ConcreteWidget</i> as a replacement for <i>AbstractWidget</i>. While <i>AbstractWidget</i> does not actually have to be abstract, it is generally an interface that <i>ConcreteWidget</i> implements. This macro should appear as part of the definition of <i>ConcreteWidget</i>.</p>
<p>Unless explicitly specified in the <tt>Trolltech/ServerWidgets</tt> file, a widget specified in this fashion if <i>Feature</i> is currently provided by Qtopia, as returned by the <a href="qtopiafeatures.html#hasFeature">QtopiaFeatures::hasFeature</a>() method.</p>
<p>For example,</p>
<pre><span class="comment">    // touchscreendialer.h</span>
    class TouchscreenDialerScreen : public QAbstractDialerScreen
    {
        <span class="comment">// ...</span>
    };

<span class="comment">    // touchscreendialer.cpp</span>
    QTOPIA_REPLACE_WIDGET_WHEN(QAbstractDialerScreen, TouchscreenDialerScreen, Touchscreen);</pre>
<h3 class="fn"><a name="QTOPIA_STATIC_TASK"></a>QTOPIA_STATIC_TASK (  <i>TaskName</i>,  <i>Function</i> )</h3>
<p>Install a functional task. A functional task is one that does not consist of an instantiable object, but is, instead, a simple function. Static tasks can obviously not provide interfaces.</p>
<p><i>TaskName</i> should be set to the name of the task, and <i>Function</i> to the static function to call to run the task.</p>
<p>As the QTOPIA_STATIC_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_TASK"></a>QTOPIA_TASK (  <i>TaskName</i>,  <i>Object</i> )</h3>
<p>Mark the <i>Object</i> as task <i>TaskName</i>. Only <a href="qobject.html">QObject</a> derived types may be tasks.</p>
<p>As the QTOPIA_TASK() macro defines symbols, it should appear only in the implementation file of a task, and not in the header file.</p>
<h3 class="fn"><a name="QTOPIA_TASK_INTERFACE"></a>QTOPIA_TASK_INTERFACE (  <i>ClassName</i> )</h3>
<p>Mark the specified <a href="qobject.html">QObject</a>-derived <i>ClassName</i> as a task interface. Any class interface that is required to support the qtopiaTask&lt;&gt;() or qtopiaTasks&lt;&gt;() request mechanism must be marked as a task interface.</p>
<p>The QTOPIA_TASK_INTERFACE() macro must be used in a header file, immediately following the interface's declaration.</p>
<p>If the interface is not a <a href="qobject.html">QObject</a> type, but rather a Qt Q_INTERFACE() style interface, use the <a href="qtopiaserverapplication.html#QTOPIA_TASK_QINTERFACE">QTOPIA_TASK_QINTERFACE</a>() macro instead.</p>
<h3 class="fn"><a name="QTOPIA_TASK_PROVIDES"></a>QTOPIA_TASK_PROVIDES (  <i>TaskName</i>,  <i>Interface</i> )</h3>
<p>Indicate that the task <i>TaskName</i> provides <i>Interface</i>, as previously declared by QTOPIA_TASK_INTERFACE. A task can provide more than one interface.</p>
<p>For a task to support the interface, it must either inherit directly from the interface or aggregate itself with an object that does during its construction. The <a href="qtopiaserverapplication.html#addAggregateObject">QtopiaServerApplication::addAggregateObject</a>() method can be used to aggregate a task with another object.</p>
<h3 class="fn"><a name="QTOPIA_TASK_QINTERFACE"></a>QTOPIA_TASK_QINTERFACE (  <i>InterfaceName</i> )</h3>
<p>Mark the specified <i>InterfaceName</i> as a task interface. Any class interface that is required to support the qtopiaTask&lt;&gt;() or qtopiaTasks&lt;&gt;() request mechanism must be marked as a task interface.</p>
<p>The QTOPIA_TASK_!<a href="messageserver.html#interface">INTERFACE</a>() macro must be used in a header file, immediately following the interface's declaration.</p>
<p><i>InterfaceName</i> should be a Qt Q_INTERFACE style interface. If you want to use a <a href="qobject.html">QObject</a> derived type as an interface, use the <a href="qtopiaserverapplication.html#QTOPIA_TASK_INTERFACE">QTOPIA_TASK_INTERFACE</a>() macro instead.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Trolltech</td>
<td align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Extended 4.4.3</div></td>
</tr></table></div></address></body>
</html>

<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt 4.4: QtXmlPatterns Module</title>
  <link rel="prev" href="qtxml.html" />
  <link rel="contents" href="modules.html" />
  <link rel="next" href="phonon-module.html" />
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="namespaces.html"><font color="#004faf">All&nbsp;Namespaces</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"></td></tr></table><p>
[Previous: <a href="qtxml.html">QtXml Module</a>]
[<a href="modules.html">Qt's Modules</a>]
[Next: <a href="phonon-module.html">Phonon Module</a>]
</p>
<h1 class="title">QtXmlPatterns Module<br /><span class="subtitle"></span>
</h1>
<p>An overview of Qt's support for using XQuery and XPath in Qt programs. <a href="#details">More...</a></p>
<h2>Classes</h2>
<p><table width="100%" class="annotated" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><th><a href="qabstractmessagehandler.html">QAbstractMessageHandler</a></th><td>Callback interface for handling messages</td></tr>
<tr valign="top" class="even"><th><a href="qabstracturiresolver.html">QAbstractUriResolver</a></th><td>Callback interface for resolving Uniform Resource Identifiers</td></tr>
<tr valign="top" class="odd"><th><a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a></th><td>Abstract base class for modeling non-XML data to look like XML for QXmlQuery</td></tr>
<tr valign="top" class="even"><th><a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a></th><td>Callback interface for transforming the output of a QXmlQuery</td></tr>
<tr valign="top" class="odd"><th><a href="qsimplexmlnodemodel.html">QSimpleXmlNodeModel</a></th><td>Implementation of QAbstractXmlNodeModel sufficient for many common cases</td></tr>
<tr valign="top" class="even"><th><a href="qsourcelocation.html">QSourceLocation</a></th><td>Identifies a location in a resource by URI, line, and column</td></tr>
<tr valign="top" class="odd"><th><a href="qxmlformatter.html">QXmlFormatter</a></th><td>Implementation of QXmlSerializer for transforming XQuery output into formatted XML</td></tr>
<tr valign="top" class="even"><th><a href="qxmlitem.html">QXmlItem</a></th><td>Contains either an XML node or an atomic value</td></tr>
<tr valign="top" class="odd"><th><a href="qxmlname.html">QXmlName</a></th><td>Represents the name of an XML node, in an efficient, namespace-aware way</td></tr>
<tr valign="top" class="even"><th><a href="qxmlnamepool.html">QXmlNamePool</a></th><td>Table of shared strings referenced by instances of QXmlName</td></tr>
<tr valign="top" class="odd"><th><a href="qxmlnodemodelindex.html">QXmlNodeModelIndex</a></th><td>Identifies a node in an XML node model subclassed from QAbstractXmlNodeModel</td></tr>
<tr valign="top" class="even"><th><a href="qxmlquery.html">QXmlQuery</a></th><td>Performs XQueries on XML data, or on non-XML data modeled to look like XML</td></tr>
<tr valign="top" class="odd"><th><a href="qxmlresultitems.html">QXmlResultItems</a></th><td>Iterates through the results of evaluating an XQuery in QXmlQuery</td></tr>
<tr valign="top" class="even"><th><a href="qxmlserializer.html">QXmlSerializer</a></th><td>Implementation of QAbstractXmlReceiver for transforming XQuery output into unformatted XML</td></tr>
</table></p>
<a name="details"></a>
<h2>Detailed Description</h2>
<a name="patternist"></a><ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#advantages-of-using-qtxmlpatterns-and-xquery">Advantages of using QtXmlPatterns and XQuery</a></li>
<li><a href="#using-the-qtxmlpatterns-module">Using the QtXmlPatterns module</a></li>
<ul><li><a href="#running-the-query-engine-from-your-qt-application">Running the query engine from your Qt application</a></li>
<li><a href="#running-the-query-engine-from-the-command-line-utility">Running the query engine from the command line utility</a></li>
</ul>
<li><a href="#the-xquery-data-model">The XQuery Data Model</a></li>
<ul><li><a href="#binding-program-variables-to-xquery-variables">Binding program variables to XQuery variables</a></li>
<ul><li><a href="#binding-to-qvariant-time">Binding To QVariant::Time</a></li>
<li><a href="#binding-to-qvariantlist">Binding To QVariantList</a></li>
</ul>
<li><a href="#interpreting-xquery-results">Interpreting XQuery results</a></li>
<ul><li><a href="#handling-qxmlnames">Handling QXmlNames</a></li>
<li><a href="#no-mapping-for-xs-time">No mapping for xs:time</a></li>
</ul>
</ul>
<li><a href="#using-xquery-with-non-xml-data">Using XQuery with Non-XML Data</a></li>
<li><a href="#more-on-using-qtxmlpatterns-with-non-xml-data">More on using QtXmlPatterns with non-XML Data</a></li>
<li><a href="#security-considerations">Security Considerations</a></li>
<ul><li><a href="#code-injection">Code Injection</a></li>
<li><a href="#denial-of-service-attacks">Denial of Service Attacks</a></li>
</ul>
<li><a href="#features-and-conformance">Features and Conformance</a></li>
<ul><li><a href="#conformance">Conformance</a></li>
<li><a href="#resource-loading">Resource Loading</a></li>
</ul>
</ul>
<a name="introduction"></a>
<h3>Introduction</h3>
<p>XQuery is a language for traversing XML documents to select and aggregate items of interest and to transform them for output as XML or some other format. XPath is the <i>element selection</i> part of XQuery.</p>
<p>The QtXmlPatterns module supports using <a href="http://www.w3.org/TR/xquery">XQuery 1.0</a> and <a href="http://www.w3.org/TR/xpath20">XPath 2.0</a> in Qt applications, for querying XML data <i>and</i> for querying <a href="qabstractxmlnodemodel.html">non-XML data that can be modeled to look like XML</a>. The QtXmlPatterns module is included in the <a href="commercialeditions.html#qt-full-framework-edition">Qt Full Framework Edition</a>, and the <a href="opensourceedition.html">Qt Open Source Edition</a>. Readers who are not familiar with the XQuery/XPath language can read <a href="xquery-introduction.html">A Short Path to XQuery</a> for a brief introduction.</p>
<a name="advantages-of-using-qtxmlpatterns-and-xquery"></a>
<h3>Advantages of using QtXmlPatterns and XQuery</h3>
<p>The XQuery/XPath language simplifies data searching and transformation tasks by eliminating the need for doing a lot of C++ or Java procedural programming for each new query task. Here is an XQuery that constructs a bibliography of the contents of a library:</p>
<a name="qtxmlpatterns-example-query"></a><pre> &lt;bibliography&gt;
 {doc(&quot;library.xml&quot;)/bib/book[publisher=&quot;Addison-Wesley&quot; and @year&gt;1991]/&lt;book year=&quot;{@year}&quot;&gt;{title}&lt;/book&gt;}
 &lt;/bibliography&gt;</pre>
<p>First, the query opens a <tt>&lt;bibliography&gt;</tt> element in the output. The <a href="xquery-introduction.html#using-path-expressions-to-match-select-items">embedded path expression</a> then loads the XML document describing the contents of the library (<tt>library.xml</tt>) and begins the search. For each <tt>&lt;book&gt;</tt> element it finds, where the publisher was Addison-Wesley and the publication year was after 1991, it creates a new <tt>&lt;book&gt;</tt> element in the output as a child of the open <tt>&lt;bibliography&gt;</tt> element. Each new <tt>&lt;book&gt;</tt> element gets the book's title as its contents and the book's publication year as an attribute. Finally, the <tt>&lt;bibliography&gt;</tt> element is closed.</p>
<p>The advantages of using QtXmlPatterns and XQuery in your Qt programs are summarized as follows:</p>
<ul>
<li><b>Ease of development</b>: All the C++ programming required to perform data query tasks can be replaced by a simple XQuery like the example above.</li>
<li><b>Comprehensive functionality</b>: The <a href="http://www.w3.org/TR/xquery/#id-expressions">expression syntax</a> and rich set of <a href="http://www.w3.org/TR/xpath-functions">functions and operators</a> provided by XQuery are sufficient for performing any data searching, selecting, and sorting tasks.</li>
<li><b>Conformance to standards</b>: Conformance to all applicable XML and XQuery standards ensures that QtXmlPatterns can always process XML documents generated by other conformant applications, and that XML documents created with QtXmlPatterns can be processed by other conformant applications.</li>
<li><b>Maximal flexibility</b> The QtXmlPatterns module can be used to query XML data <i>and</i> non-XML data that can be <a href="qabstractxmlnodemodel.html">modeled to look like XML</a>.</li>
</ul>
<a name="using-the-qtxmlpatterns-module"></a>
<h3>Using the QtXmlPatterns module</h3>
<p>There are two ways QtXmlPatterns can be used to evaluate queries. You can run the query engine in your Qt application using the QtXmlPatterns C++ API, or you can run the query engine from the command line using Qt's <tt>xmlpatterns</tt> command line utility.</p>
<a name="running-the-query-engine-from-your-qt-application"></a>
<h4>Running the query engine from your Qt application</h4>
<p>To access the QtXmlPatterns C++ API from your Qt application, include the QtXmlPatterns classes at compile time:</p>
<pre> #include &lt;QtXmlPatterns&gt;</pre>
<p>Link the compiled application with the QtXmlPatterns module by adding the following line to the <a href="qmake-project-files.html#declaring-qt-libraries">QT line</a> in your qmake <tt>.pro</tt> file:</p>
<pre> QT += xmlpatterns</pre>
<p>If we save the example XQuery shown above in a text file (e.g&#x2e; <tt>myquery.xq</tt>), we can run it from a Qt application using a standard QtXmlPatterns code sequence:</p>
<pre>     QFile xq(&quot;myquery.xq&quot;);

     QXmlQuery query;
     query.setQuery(&amp;xq, QUrl::fromLocalFile(xq.fileName()));

     QXmlSerializer serializer(query, myOutputDevice);
     query.evaluateTo(&amp;serializer);</pre>
<p>First construct a <a href="qfile.html">QFile</a> for the text file containing the XQuery (<tt>myquery.xq</tt>). Then create an instance of <a href="qxmlquery.html">QXmlQuery</a> and call its <a href="qxmlquery.html#setQuery">setQuery()</a> function to load and parse the XQuery file. Then create an <a href="qxmlserializer.html">XML serializer</a> to output the query's result set as unformatted XML. Finally, call the <a href="qxmlquery.html#evaluateTo">evaluateTo()</a> function to evaluate the query and serialize the results as XML.</p>
<p><b>Note:</b> If you compile Qt yourself, the QtXmlPatterns module will <i>not</i> be built if exceptions are disabled, or if you compile Qt with a compiler that doesn't support member templates, e.g&#x2e;, MSVC 6.</p>
<p>See the <a href="qxmlquery.html">QXmlQuery</a> documentation for more information about the QtXmlPatterns C++ API.</p>
<a name="running-the-query-engine-from-the-command-line-utility"></a>
<h4>Running the query engine from the command line utility</h4>
<p><i>xmlpatterns</i> is a command line utility for running XQueries. It expects the name of a file containing the XQuery text.</p>
<pre> xmlpatterns myQuery.xq</pre>
<p>The XQuery in <tt>myQuery.xq</tt> will be evaluated and its output written to <tt>stdout</tt>. Pass the <tt>-help</tt> switch to get the list of input flags and their meanings.</p>
<p>xmlpatterns can be used in scripting. However, the descriptions and messages it outputs were not meant to be parsed and may be changed in future releases of Qt.</p>
<a name="qtxdm"></a><a name="the-xquery-data-model"></a>
<h3>The XQuery Data Model</h3>
<p>XQuery represents data items as <i>atomic values</i> or <i>nodes</i>. An atomic value is a value in the domain of one of the <a href="http://www.w3.org/TR/xmlschema-2/#built-in-datatypes">built-in datatypes</a> defined in <a href="http://www.w3.org/TR/xmlschema-2">Part 2</a> of the W3C XML Schema. A node is normally an XML element or attribute, but when non-XML data is <a href="qabstractxmlnodemodel.html">modeled to look like XML</a>, a node can also represent a non-XML data items.</p>
<p>When you run an XQuery using the C++ API in a Qt application, you will often want to bind program variables to $variables in the XQuery. After the query is evaluated, you will want to interpret the sequence of data items in the result set.</p>
<a name="binding-program-variables-to-xquery-variables"></a>
<h4>Binding program variables to XQuery variables</h4>
<p>When you want to run a parameterized XQuery from your Qt application, you will need to <a href="qxmlquery.html#bindVariable">bind variables</a> in your program to $name variables in your XQuery.</p>
<p>Suppose you want to parameterize the bibliography XQuery in the example above. You could define variables for the catalog that contains the library (<tt>$file</tt>), the publisher name (<tt>$publisher</tt>), and the year of publication (<tt>$year</tt>):</p>
<a name="qtxmlpatterns-example-query2"></a><pre> &lt;bibliography&gt;
 {
     doc($file)/bib/book[publisher = $publisher and @year &gt; $year]/&lt;book year=&quot;{@year}&quot;&gt;{title}&lt;/book&gt;
 }
 &lt;/bibliography&gt;</pre>
<p>Modify the QtXmlPatterns code to use one of the <a href="qxmlquery.html#bindVariable">bindVariable()</a> functions to bind a program variable to each XQuery $variable:</p>
<pre>     QFile xq(&quot;myquery.xq&quot;);
     QString fileName(&quot;the filename&quot;);
     QString publisherName(&quot;the publisher&quot;);
     qlonglong year = 1234;

     QXmlQuery query;
     query.setQuery(&amp;xq, QUrl::fromLocalFile(xq.fileName()));

     query.bindVariable(&quot;file&quot;, QVariant(fileName));
     query.bindVariable(&quot;publisher&quot;, QVariant(publisherName));
     query.bindVariable(&quot;year&quot;, QVariant(year));

     QXmlSerializer serializer(query, myOutputDevice);
     query.evaluateTo(&amp;serializer);</pre>
<p>Each program variable is passed to QtXmlPatterns as a <a href="qvariant.html">QVariant</a> of the type of the C++ variable or constant from which it is constructed. Note that QtXmlPatterns assumes that the type of the <a href="qvariant.html">QVariant</a> in the bindVariable() call is the correct type, so the $variable it is bound to must be used in the XQuery accordingly. The following table shows how <a href="qvariant.html">QVariant</a> types are mapped to XQuery $variable types:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th><a href="qvariant.html">QVariant</a> type</th><th>XQuery $variable type</th></tr></thead>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::LongLong</a></td><td><tt>xs:integer</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::Int</a></td><td><tt>xs:integer</tt></td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::UInt</a></td><td><tt>xs:nonNegativeInteger</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::ULongLong</a></td><td><tt>xs:unsignedLong</tt></td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::String</a></td><td><tt>xs:string</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::Double</a></td><td><tt>xs:double</tt></td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::Bool</a></td><td><tt>xs:boolean</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::Double</a></td><td><tt>xs:decimal</tt></td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::ByteArray</a></td><td><tt>xs:base64Binary</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::StringList</a></td><td><tt>xs:string*</tt></td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::Url</a></td><td><tt>xs:string</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::Date</a></td><td><tt>xs:date</tt>.</td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td><td><tt>xs:dateTime</tt></td></tr>
<tr valign="top" class="even"><td><a href="qvariant.html#Type-enum">QVariant::Time</a>.</td><td><tt>xs:time</tt>. (see <a href="#binding-to-time">Binding To QVariant::Time</a> below)</td></tr>
<tr valign="top" class="odd"><td><a href="qvariant.html#QVariantList-typedef">QVariantList</a></td><td>(see <a href="#binding-to-qvariantlist">Binding To QVariantList</a> below)</td></tr>
</table></p>
<p>A type not shown in the table is not supported and will cause undefined XQuery behavior or a $variable binding error, depending on the context in the XQuery where the variable is used.</p>
<a name="binding-to-time"></a><a name="binding-to-qvariant-time"></a>
<h5>Binding To QVariant::Time</h5>
<p>Because the instance of <a href="qtime.html">QTime</a> used in <a href="qvariant.html#Type-enum">QVariant::Time</a> does not include a zone offset, an instance of <a href="qvariant.html#Type-enum">QVariant::Time</a> should not be bound to an XQuery variable of type <tt>xs:time</tt>, unless the <a href="qtime.html">QTime</a> is UTC. When binding a non-UTC <a href="qtime.html">QTime</a> to an XQuery variable, it should first be passed as a string, or converted to a <a href="qdatetime.html">QDateTime</a> with an arbitrary date, and then bound to an XQuery variable of type <tt>xs:dateTime</tt>.</p>
<a name="binding-to-qvariantlist"></a><a name="binding-to-qvariantlist"></a>
<h5>Binding To QVariantList</h5>
<p>A <a href="qvariant.html#QVariantList-typedef">QVariantList</a> can be bound to an XQuery $variable. All the <a href="qvariant.html">QVariant</a>s in the list must be of the same atomic type, and the $variable the variant list is bound to must be of that same atomic type. If the QVariants in the list are not all of the same atomic type, the XQuery behavior is undefined.</p>
<a name="interpreting-xquery-results"></a>
<h4>Interpreting XQuery results</h4>
<p>When the results of an XQuery are returned in a sequence of <a href="qxmlresultitems.html">result items</a>, atomic values in the sequence are treated as instances of <a href="qvariant.html">QVariant</a>. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard QtXmlPatterns code sequence to call the overload of <a href="qxmlquery.html#evaluateTo">QXmlQuery::evaluateTo</a>() that populates a sequence of <a href="qxmlresultitems.html">result items</a> with the XQuery results:</p>
<pre>     QFile xq(&quot;myquery.xq&quot;);
     QString fileName(&quot;the filename&quot;);
     QString publisherName(&quot;the publisher&quot;);
     qlonglong year = 1234;

     QXmlQuery query;
     query.setQuery(&amp;xq, QUrl::fromLocalFile(xq.fileName()));

     query.bindVariable(&quot;file&quot;, QVariant(fileName));
     query.bindVariable(&quot;publisher&quot;, QVariant(publisherName));
     query.bindVariable(&quot;year&quot;, QVariant(year));

     QXmlResultItems result;
     query.evaluateTo(&amp;result);
     QXmlItem item(result.next());
     while (!item.isNull()) {
         if (item.isAtomicValue()) {
             QVariant v = item.toAtomicValue();
             switch (v.type()) {
                 case QVariant::LongLong:
                     <span class="comment">// xs:integer</span>
                     break;
                 case QVariant::String:
                     <span class="comment">// xs:string</span>
                     break;
                 default:
                     <span class="comment">// error</span>
                     break;
             }
         }
         else if (item.isNode()) {
             QXmlNodeModelIndex i = item.toNodeModelIndex();
             <span class="comment">// process node</span>
         }
         item = result.next();
     }</pre>
<p>Iterate through the <a href="qxmlresultitems.html">result items</a> and test each <a href="qxmlitem.html">QXmlItem</a> to see if it is an atomic value or a node. If it is an atomic value, convert it to a <a href="qvariant.html">QVariant</a> with <a href="qxmlitem.html#toAtomicValue">toAtomicValue()</a> and switch on its <a href="qvariant.html#type">variant type</a> to handle all the atomic values your XQuery might return. The following table shows the <a href="qvariant.html">QVariant</a> type to expect for each atomic value type (or <a href="qxmlname.html">QXmlName</a>):</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>XQuery result item type</th><th><a href="qvariant.html">QVariant</a> type returned</th></tr></thead>
<tr valign="top" class="odd"><td><tt>xs:QName</tt></td><td><a href="qxmlname.html">QXmlName</a> (see <a href="#handling-qxmlnames">Handling QXmlNames</a> below)</td></tr>
<tr valign="top" class="even"><td><tt>xs:integer</tt></td><td><a href="qvariant.html#Type-enum">QVariant::LongLong</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:string</tt></td><td><a href="qvariant.html#Type-enum">QVariant::String</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:string*</tt></td><td><a href="qvariant.html#Type-enum">QVariant::StringList</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:double</tt></td><td><a href="qvariant.html#Type-enum">QVariant::Double</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:float</tt></td><td><a href="qvariant.html#Type-enum">QVariant::Double</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:boolean</tt></td><td><a href="qvariant.html#Type-enum">QVariant::Bool</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:decimal</tt></td><td><a href="qvariant.html#Type-enum">QVariant::Double</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:hexBinary</tt></td><td><a href="qvariant.html#Type-enum">QVariant::ByteArray</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:base64Binary</tt></td><td><a href="qvariant.html#Type-enum">QVariant::ByteArray</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:gYear</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:gYearMonth</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:gMonthDay</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:gDay</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:gMonth</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:anyURI</tt></td><td><a href="qvariant.html#Type-enum">QVariant::Url</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:untypedAtomic</tt></td><td><a href="qvariant.html#Type-enum">QVariant::String</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:ENTITY</tt></td><td><a href="qvariant.html#Type-enum">QVariant::String</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:date</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="even"><td><tt>xs:dateTime</tt></td><td><a href="qvariant.html#Type-enum">QVariant::DateTime</a></td></tr>
<tr valign="top" class="odd"><td><tt>xs:time</tt></td><td>(see <a href="#xstime-not-mapped">No mapping for xs:time</a> below)</td></tr>
</table></p>
<a name="handling-qxmlnames"></a><a name="handling-qxmlnames"></a>
<h5>Handling QXmlNames</h5>
<p>If your XQuery can return atomic value items of type <tt>xs:QName</tt>, they will appear in your <a href="qxmlresultitems.html">QXmlResultItems</a> as instances of <a href="qxmlname.html">QXmlName</a>. Since the <a href="qvariant.html">QVariant</a> class does not support the <a href="qxmlname.html">QXmlName</a> class directly, extracting them from <a href="qxmlresultitems.html">QXmlResultItems</a> requires a bit of slight-of-hand using the <a href="qmetatype.html">Qt metatype system</a>. We must modify our example to use a couple of template functions, a friend of <a href="qmetatype.html">QMetaType</a> (qMetaTypeId&lt;T&gt;()) and a friend of <a href="qvariant.html">QVariant</a> (qVariantValue&lt;T&gt;()):</p>
<pre>     QFile xq(&quot;myquery.xq&quot;);

     QXmlQuery query;
     query.setQuery(&amp;xq, QUrl::fromLocalFile(xq.fileName()));

     QXmlResultItems result;
     query.evaluateTo(&amp;result);
     QXmlItem item(result.next());
     while (!item.isNull()) {
         if (item.isAtomicValue()) {
             QVariant v = item.toAtomicValue();
             switch (v.type()) {
                 case QVariant::LongLong:
                     <span class="comment">// xs:integer</span>
                     break;
                 case QVariant::String:
                     <span class="comment">// xs:string</span>
                     break;
                 default:
                     if (v.userType() == qMetaTypeId&lt;QXmlName&gt;()) {
                         QXmlName n = qVariantValue&lt;QXmlName&gt;(v);
                         <span class="comment">// process QXmlName n...</span>
                     }
                     else {
                         <span class="comment">// error</span>
                     }
                     break;
             }
         }
         else if (item.isNode()) {
             QXmlNodeModelIndex i = item.toNodeModelIndex();
             <span class="comment">// process node</span>
         }
         item = result.next();
     }</pre>
<p>To access the strings in a <a href="qxmlname.html">QXmlName</a> returned by an <a href="qxmlquery.html#evaluateTo">XQuery evaluation</a>, the <a href="qxmlname.html">QXmlName</a> must be accessed with the <a href="qxmlnamepool.html">name pool</a> from the instance of <a href="qxmlquery.html">QXmlQuery</a> that was used for the evaluation.</p>
<a name="xstime-not-mapped"></a><a name="no-mapping-for-xs-time"></a>
<h5>No mapping for xs:time</h5>
<p>An instance of <tt>xs:time</tt> can't be represented correctly as an instance of <a href="qvariant.html#Type-enum">QVariant::Time</a>, unless the <tt>xs:time</tt> is a UTC time. This is because xs:time has a zone offset (0 for UTC) in addition to the time value, which the <a href="qtime.html">QTime</a> in <a href="qvariant.html#Type-enum">QVariant::Time</a> does not have. This means that if an XQuery tries to return an atomic value of type <tt>xs:time</tt>, an invalid <a href="qvariant.html">QVariant</a> will be returned. A query can return an atomic value of type xs:time by either converting it to an <tt>xs:dateTime</tt> with an arbitrary date, or to an <tt>xs:string</tt>.</p>
<a name="using-xquery-with-non-xml-data"></a>
<h3>Using XQuery with Non-XML Data</h3>
<p>Although the XQuery language was designed for querying XML, with QtXmlPatterns one can use XQuery for querying any data that can be modeled to look like XML. Non-XML data is modeled to look like XML by loading it into a custom subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, where it is then presented to the QtXmlPatterns XQuery engine via the same API the XQuery engine uses for querying XML.</p>
<p>When QtXmlPatterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file <i>myOrders.xml</i> to find all the skin care product orders and output them ordered by shipping date.</p>
<pre> &lt;result&gt;
     &lt;para&gt;The following skin care products have shipped, ordered by shipping date(oldest first):&lt;/para&gt;
     {
         for $i in doc(&quot;myOrders.xml&quot;)/orders/order[@product = &quot;Acme Skin Care&quot;]
         order by xs:date($i/@shippingDate) descending
         return $i
     }
 &lt;/result&gt;</pre>
<p>QtXmlPatterns can be used out of the box to perform this query, provided <i>myOrders.xml</i> actually contains well-formed XML. It can be loaded directly into the default XML node model and traversed. But suppose we want QtXmlPatterns to perform queries on the hierarchical structure of the local file system. The default XML node model in QtXmlPatterns is not suitable for navigating the file system, because there is no XML file to load that contains a description of it. Such an XML file, if it existed, might look something like this:</p>
<pre> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;directory name=&quot;home&quot;&gt;

     &lt;file name=&quot;myNote.txt&quot; mimetype=&quot;text/plain&quot; size=&quot;8&quot; extension=&quot;txt&quot; uri=&quot;file:///home/frans/myNote.txt&quot;&gt;
         &lt;content asBase64Binary=&quot;TXkgTm90ZSE=&quot; asStringFromUTF-8=&quot;My Note!&quot;/&gt;
     &lt;/file&gt;

     &lt;directory name=&quot;src&quot;&gt;
         ...
     &lt;/directory&gt;

     ...

 &lt;/directory&gt;</pre>
<p>The <a href="xmlpatterns-filetree.html">File System Example</a> does exactly this.</p>
<p>There is no such file to load into the default XML node model, but one can write a subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> to represent the file system. This custom XML node model, once populated with all the directory and file descriptors obtained directly from the system, presents the complete file system hierarchy to the query engine via the same API used by the default XML node model to present the contents of an XML file. In other words, once the custom XML node model is populated, it presents the file system to the query engine as if a description of it had been loaded into the default XML node model from an XML file like the one shown above.</p>
<p>Now we can write an XQuery to find all the XML files and parse them to find the ones that don't contain well-formed XML.</p>
<pre> &lt;html&gt;
     &lt;body&gt;
         {
             $myRoot//file[@mimetype = 'text/xml' or @mimetype = 'application/xml']
             /
             (if(doc-available(@uri))
              then ()
              else &lt;p&gt;Failed to parse file {@uri}.&lt;/p&gt;)
         }
     &lt;/body&gt;
 &lt;/html&gt;</pre>
<p>Without QtXmlPatterns, there is no simple way to solve this kind of problem. You might do it by writing a C++ program to traverse the file system, sniff out all the XML files, and submit each one to an XML parser to test that it contains valid XML. The C++ code required to write that program will probably be more complex than the C++ code required to subclass <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, but even if the two are comparable, your custom C++ program can be used only for that one task, while your custom XML node model can be used by any XQuery that must navigate the file system.</p>
<p>The general approach to using XQuery to perform queries on non-XML data has been a three step process. In the first step, the data is loaded into a non-XML data model. In the second step, the non-XML data model is serialized as XML and output to XML (text) files. In the final step, an XML tool loads the XML files into a second, XML data model, where the XQueries can be performed. The development cost of implementing this process is often high, and the three step system that results is inefficient because the two data models must be built and maintained separately.</p>
<p>With QtXmlPatterns, subclassing <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> eliminates the transformation required to convert the non-XML data model to the XML data model, because there is only ever one data model required. The non-XML data model presents the non-XML data to the query engine via the XML data model API. Also, since the query engine uses the API to access the <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a>, the data model subclass can construct the elements, attributes and other data on demand, responding to the query's specific requests. This can greatly improve efficiency, because it means the entire model might not have to be built. For example, in the file system model above, it is not necessary to build an instance for a whole XML file representing the whole file system. Instead nodes are created on demand, which also likely is a small subset of the file system.</p>
<p>Examples of other places where XQuery could be used in QtXmlPatterns to query non-XML data:</p>
<ul>
<li>The internal representation for word processor documents</li>
<li>The set of dependencies for a software build system</li>
<li>The hierarchy (or graph) that links a set of HTML documents from a web crawler</li>
<li>The images and meta-data in an image collection</li>
<li>The set of D-Bus interfaces available in a system</li>
<li>A <a href="qobject.html">QObject</a> hierarchy, as seen in the <a href="xmlpatterns-qobjectxmlmodel.html">QObject XML Model example</a>.</li>
</ul>
<p>See the <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> documentation for information about how to implement custom XML node models.</p>
<a name="more-on-using-qtxmlpatterns-with-non-xml-data"></a>
<h3>More on using QtXmlPatterns with non-XML Data</h3>
<p>Subclassing <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> to let the query engine access non-XML data by the same API it uses for XML is the feature that enables QtXmlPatterns to query non-XML data with XQuery. It allows XQuery to be used as a mapping layer between different non-XML node models or between a non-XML node model and the built-in XML node model. Once the subclass(es) of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> have been written, XQuery can be used to select a set of elements from one node model, transform the selected elements, and then write them out, either as XML using <a href="qxmlquery.html#evaluateTo">QXmlQuery::evaluateTo</a>() and <a href="qxmlserializer.html">QXmlSerializer</a>, or as some other format using a subclass of <a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a>.</p>
<p>Consider a word processor application that must import and export data in several different formats. Rather than writing a lot of C++ code to convert each input format to an intermediate form, and more C++ code to convert the intermediate form back to each output format, one can implement a solution based on QtXmlPatterns that uses simple XQueries to transform each XML or non-XML format (e.g&#x2e; MathFormula.xml below) to the intermediate form (e.g&#x2e; the DocumentRepresentation node model class below), and more simple XQueries to transform the intermediate form back to each XML or non-XML format.</p>
<p align="center"><img src="images/patternist-wordProcessor.png" /></p><p>Because CSV files are not XML, a subclass of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> is used to present the CSV data to the XQuery engine as if it were XML. What are not shown are the subclasses of <a href="qabstractxmlreceiver.html">QAbstractXmlReceiver</a> that would then send the selected elements into the DocumentRepresentation node model, and the subclasses of <a href="qabstractxmlnodemodel.html">QAbstractXmlNodeModel</a> that would ultimately write the output files in each format.</p>
<a name="security-considerations"></a>
<h3>Security Considerations</h3>
<a name="code-injection"></a>
<h4>Code Injection</h4>
<p>Like SQL, XQuery is vulnerable to <a href="http://en.wikipedia.org/wiki/Code_injection">code injection attacks</a>. If an XQuery is constructed by concatenation, where concatenated strings can come from user input, the final XQuery can become malevolent. The best way to prevent code injection attacks is to not construct XQueries from user-written strings, but only accept user data input using <a href="qvariant.html">QVariant</a> and variable bindings. See <a href="qxmlquery.html#bindVariable">QXmlQuery::bindVariable</a>()</p>
<p>The articles <a href="http://www.ibm.com/developerworks/xml/library/x-xpathinjection.html">Avoid the dangers of XPath injection, Robi Sen</a> and <a href="http://www.packetstormsecurity.org/papers/bypass/Blind_XPath_Injection_20040518.pdf">Blind XPath Injection, Amit Klein</a> discuss the XQuery code injection problem in more detail.</p>
<a name="denial-of-service-attacks"></a>
<h4>Denial of Service Attacks</h4>
<p>Applications using QtXmlPatterns are subject to the same software limits as any other system. Generally, these can not be checked. This means QtXmlPatterns does not prevent rogue queries from consuming too many resources. For example, a query could take too much time to execute, or could attempt to transfer too much data. Or a query could cause an unreasonable amount of recursion, which could crash the system. XQueries can do these things accidentally, but they can also be meant as deliberate, denial of service attacks.</p>
<a name="features-and-conformance"></a>
<h3>Features and Conformance</h3>
<a name="conformance"></a>
<h4>Conformance</h4>
<p>QtXmlPatterns aims at being a <a href="http://www.w3.org/TR/xquery/#id-xquery-conformance">conformant XQuery processor</a>. Apart from adhering to {http://www.w3.org/TR/xquery/#id-minimal-conformance} {Minimal Conformance}, QtXmlPatterns supports the <a href="http://www.w3.org/TR/xquery/#id-serialization-feature">Serialization Feature</a> and the <a href="http://www.w3.org/TR/xquery/#id-full-axis-feature">Full Axis Feature</a>. QtXmlPatterns passes 97% of the tests in the <a href="http://www.w3.org/XML/Query/test-suite">XML Query Test Suite</a>, and it is expected this will improve over time. Areas where conformance may be questionable and where behavior may be changed in future releases are:</p>
<ul>
<li>Regular expression support is currently not conformant but follows Qt's <a href="qregexp.html">QRegExp</a> standard syntax.</li>
<li>Operators for <tt>xs:time</tt>, <tt>xs:date</tt>, and <tt>xs:dateTime</tt> are incomplete.</li>
<li>Formatting of very large or very small <tt>xs:double</tt>, <tt>xs:float</tt>, and <tt>xs:decimal</tt> values may be incorrect.</li>
<li>Some corner cases involving namespaces and element constructors are incorrect.</li>
</ul>
<p>XML 1.0 and XML Namespaces 1.0 are supported, as opposed to the 1.1 versions. When a strings is passed to a query as a <a href="qstring.html">QString</a>, the characters must be XML 1.0 characters. Otherwise, the behavior is undefined. This is not checked.</p>
<p>Since XPath 2.0 is a subset of XQuery 1.0, it is supported.</p>
<p>The specifications discusses conformance further: <a href="http://www.w3.org/TR/xquery/">XQuery 1.0: An XML Query Language</a>. W3C's XQuery testing effort can be of interest as well, <a href="http://www.w3.org/XML/Query/test-suite/">XML Query Test Suite</a>.</p>
<p>Currently <tt>fn:collection()</tt> does not access any data set, and there is no API for providing data through the collection. As a result, evaluating <tt>fn:collection()</tt> returns the empty sequence. We intend to provide functionality for this in a future release of Qt.</p>
<p>Processing of XML files supports <tt>xml:id</tt>. In practice, this allows elements that have an attribute named <tt>xml:id</tt> to be looked up efficiently with the <tt>fn:id()</tt> function. See <a href="http://www.w3.org/TR/xml-id/">xml:id Version 1.0</a> for details.</p>
<p>Only queries encoded in UTF-8 are supported.</p>
<a name="resource-loading"></a>
<h4>Resource Loading</h4>
<p>When QtXmlPatterns loads an XML resource, e.g&#x2e;, using <tt>fn:doc()</tt> function, the following schemes are supported:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Scheme Name</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td><tt>file</tt></td><td>Local files.</td></tr>
<tr valign="top" class="even"><td><tt>data</tt></td><td>The bytes are encoded in the URI itself. For instance, <tt>data:application/xml,%3Ce%2F%3E</tt> is <tt>&lt;e/&gt;</tt>.</td></tr>
<tr valign="top" class="odd"><td><tt>ftp</tt></td><td>Resources retrieved via FTP.</td></tr>
<tr valign="top" class="even"><td><tt>http</tt></td><td>Resources retrieved via HTTP.</td></tr>
<tr valign="top" class="odd"><td><tt>https</tt></td><td>Resources retrieved via HTTPS. This will succeed if no SSL errors are encountered.</td></tr>
<tr valign="top" class="even"><td><tt>qrc</tt></td><td>Qt Resource files. Expressing it as an empty scheme, :/..&#x2e;, is not supported.</td></tr>
</table></p>
<p>URIs are first passed to <a href="qabstracturiresolver.html">QAbstractUriResolver</a>. Check <a href="qxmlquery.html#setUriResolver">QXmlQuery::setUriResolver</a>() for possible rewrites.</p>
<p>
[Previous: <a href="qtxml.html">QtXml Module</a>]
[<a href="modules.html">Qt's Modules</a>]
[Next: <a href="phonon-module.html">Phonon Module</a>]
</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%" align="left">Copyright &copy; 2008 Nokia</td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.4.3</div></td>
</tr></table></div></address></body>
</html>
